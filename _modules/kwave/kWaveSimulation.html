<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kwave.kWaveSimulation &mdash; k-Wave-python  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sphinx-toolbox-code.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> k-Wave-python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/contrib.html">Contribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/bmode.html">B-mode Reconstruction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Base Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../kgrid.html">kWaveGrid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kmedium.html">kMedium</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ksensor.html">kSensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ksource.html">kSource</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kspace_fo.html">kSpace First Order</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ksimulation.html">kWaveSimulation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Helper Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../simopt.html">Simulation Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recorder.html">Recorder</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../development/development_environment.html">Development Environment</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">k-Wave-python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>kwave.kWaveSimulation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kwave.kWaveSimulation</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">from</span> <span class="nn">kwave.kWaveSimulation_helper</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">kwave.kgrid</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">kwave.kmedium</span> <span class="kn">import</span> <span class="n">kWaveMedium</span>
<span class="kn">from</span> <span class="nn">kwave.ksensor</span> <span class="kn">import</span> <span class="n">kSensor</span>
<span class="kn">from</span> <span class="nn">kwave.ksource</span> <span class="kn">import</span> <span class="n">kSource</span>
<span class="kn">from</span> <span class="nn">kwave.ktransducer</span> <span class="kn">import</span> <span class="n">NotATransducer</span>
<span class="kn">from</span> <span class="nn">kwave.options</span> <span class="kn">import</span> <span class="n">SimulationOptions</span>
<span class="kn">from</span> <span class="nn">kwave.recorder</span> <span class="kn">import</span> <span class="n">Recorder</span>
<span class="kn">from</span> <span class="nn">kwave.utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">kwave.utils</span> <span class="kn">import</span> <span class="n">dotdict</span>


<div class="viewcode-block" id="kWaveSimulation"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">kWaveSimulation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">kgrid</span><span class="p">:</span> <span class="n">kWaveGrid</span><span class="p">,</span>
                 <span class="n">medium</span><span class="p">:</span> <span class="n">kWaveMedium</span><span class="p">,</span>
                 <span class="n">source</span><span class="p">,</span>
                 <span class="n">sensor</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span> <span class="o">=</span> <span class="n">kgrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">medium</span> <span class="o">=</span> <span class="n">medium</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="o">=</span> <span class="n">sensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># =========================================================================</span>
        <span class="c1"># FLAGS WHICH DEPEND ON USER INPUTS (THESE SHOULD NOT BE MODIFIED)</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># flags which control the type of simulation</span>
        <span class="c1">#: Whether simulation type is axisymmetric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userarg_axisymmetric</span>      <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axisymmetric&#39;</span><span class="p">]</span>

        <span class="c1"># flags which control the characteristics of the sensor</span>
        <span class="c1">#: Whether time reversal simulation is enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userarg_time_rev</span>          <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_rev&#39;</span><span class="p">]</span>

        <span class="c1">#: Whether sensor.mask should be re-ordered.</span>
        <span class="c1">#: True if sensor.mask is Cartesian with nearest neighbour interpolation which is calculated using a binary mask</span>
        <span class="c1">#: and thus must be re-ordered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_data</span>              <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#: Whether the sensor.mask is binary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span>        <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">#: If the sensor.mask is a list of cuboid corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userarg_cuboid_corners</span>    <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cuboid_corners&#39;</span><span class="p">]</span>

        <span class="c1">#: If tse sensor is an object of the kWaveTransducer class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_sensor</span>         <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">record</span> <span class="o">=</span> <span class="n">Recorder</span><span class="p">()</span>

        <span class="c1"># transducer source flags</span>
        <span class="c1">#: transducer is object of kWaveTransducer class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span>         <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#: Apply receive elevation focus on the transducer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># general</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">COLOR_MAP</span>                       <span class="o">=</span> <span class="n">get_color_map</span><span class="p">()</span>      <span class="c1">#: default color map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATE_SIM_TIME_STEPS</span>         <span class="o">=</span> <span class="mi">50</span>                   <span class="c1">#: time steps used to estimate simulation time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HIGHEST_PRIME_FACTOR_WARNING</span>    <span class="o">=</span> <span class="mi">7</span>                    <span class="c1">#: largest prime factor before warning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KSPACE_CFL</span>                      <span class="o">=</span> <span class="mf">0.3</span>                  <span class="c1">#: default CFL value used if kgrid.t_array is set to &#39;auto&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PSTD_CFL</span>                        <span class="o">=</span> <span class="mf">0.1</span>                  <span class="c1">#: default CFL value used if kgrid.t_array is set to &#39;auto&#39;</span>

        <span class="c1"># source types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_S_MODE_DEF</span>               <span class="o">=</span> <span class="s1">&#39;additive&#39;</span>           <span class="c1">#: source mode for stress sources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_P_MODE_DEF</span>               <span class="o">=</span> <span class="s1">&#39;additive&#39;</span>           <span class="c1">#: source mode for pressure sources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_U_MODE_DEF</span>               <span class="o">=</span> <span class="s1">&#39;additive&#39;</span>           <span class="c1">#: source mode for velocity sources</span>

        <span class="c1"># filenames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">STREAM_TO_DISK_FILENAME</span>         <span class="o">=</span> <span class="s1">&#39;temp_sensor_data.bin&#39;</span>   <span class="c1">#: default disk stream filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LOG_NAME</span>                        <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;k-Wave-Log-&#39;</span><span class="p">,</span> <span class="n">get_date_string</span><span class="p">()]</span>  <span class="c1">#: default log filename</span>

        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axisymmetric&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cuboid_corners&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_rev&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  start time: </span><span class="si">{</span><span class="n">get_date_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_compression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_shear</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#: Indexing variable corresponding to the location of all the pressure source elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#: Indexing variable corresponding to the location of all the velocity source elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#: Indexing variable corresponding to the location of all the stress source elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#: Delay mask that accounts for the beamforming delays and elevation focussing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_mask</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla1</span>  <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: absorbing fractional Laplacian operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_tau</span>     <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: absorbing fractional Laplacian coefficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla2</span>  <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: dispersive fractional Laplacian operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_eta</span>     <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: dispersive fractional Laplacian coefficient</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>             <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: Alias to kgrid.dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span>           <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: Alias to medium.density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c0</span>             <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: Alias to medium.sound_speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">equation_of_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Set equation of state variable</span>
<span class="sd">        Returns:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">absorbing</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">stokes</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;stokes&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;absorbing&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;loseless&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            False if no output of any kind is required</span>
<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blank_sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            true if sensor.mask is not defined but _max_all or _final variables are still recorded</span>
<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p_max&#39;</span><span class="p">,</span> <span class="s1">&#39;p_min&#39;</span><span class="p">,</span> <span class="s1">&#39;p_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;u_non_staggered&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;u_split_field&#39;</span><span class="p">,</span> <span class="s1">&#39;u_max&#39;</span><span class="p">,</span> <span class="s1">&#39;u_min&#39;</span><span class="p">,</span> <span class="s1">&#39;u_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;I_avg&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="n">fields</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elastic_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the simulation is elastic or fluid</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if elastic simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;pstdElastic&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic&#39;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kspace_elastic_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the simulation is k-space elastic code or an ordinary elastic code</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if elastic simulation with k-space correction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;kspaceElastic&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axisymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the code is axisymmetric</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if fluid axisymmetric simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;kspaceFirstOrderAS&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">userarg_axisymmetric</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kelvin_voigt_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the simulation is elastic with absorption</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nonuniform_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the grid is nonuniform</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if the computational grid is non-uniform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">nonuniform</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_rev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the simulation is time reversal</span>
<span class="sd">        Returns:</span>
<span class="sd">            True for time reversal simulaions using sensor.time_reversal_boundary_data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">time_reversal_boundary_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">userarg_time_rev</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elastic_time_rev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the simulation is time reversal and elastic code</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if using time reversal with the elastic code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">compute_directivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the directivity should be computed</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if directivity calculations in 2D are used by setting sensor.directivity_angle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># check for sensor directivity input and set flag</span>
                <span class="n">directivity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">directivity</span>
                <span class="k">if</span> <span class="n">directivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">directivity</span><span class="o">.</span><span class="n">angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cuboid_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether the sensor.mask is a list of cuboid corners</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">userarg_cuboid_corners</span>

    <span class="c1">##############</span>
    <span class="c1"># flags which control the types of source used</span>
    <span class="c1">##############</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># initial pressure</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether initial pressure source is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set flag</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p0_elastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># initial pressure in the elastic code</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether initial pressure source is present in the elastic code (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Not clear where this flag is set</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying pressure source is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flag to the length of the source, this allows source.p</span>
            <span class="c1"># to be shorter than kgrid.Nt</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p_labelled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># time-varying pressure with labelled source mask</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying pressure source with labelled source mask is present (default=False)</span>
<span class="sd">        Returns:</span>
<span class="sd">            True/False if labelled/binary source mask, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the mask is binary or labelled</span>
            <span class="n">p_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">p_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_ux</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying particle velocity source is used in X-direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flgs to the length of the sources, this allows the</span>
            <span class="c1"># inputs to be defined independently and be of any length</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_uy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying particle velocity source is used in Y-direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flgs to the length of the sources, this allows the</span>
            <span class="c1"># inputs to be defined independently and be of any length</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_uz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying particle velocity source is used in Z-direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flgs to the length of the sources, this allows the</span>
            <span class="c1"># inputs to be defined independently and be of any length</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_u_labelled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying velocity source with labelled source mask is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the mask is binary or labelled</span>
            <span class="n">u_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># binary source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># labelled source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_sxx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source in X-&gt;X direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_syy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source in Y-&gt;Y direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_szz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source in Z-&gt;Z direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">szz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">szz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_sxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source in X-&gt;Y direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_sxz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source in X-&gt;Z direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_syz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source in Y-&gt;Z direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_s_labelled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether time-varying stress source with labelled source mask is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">s_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the mask is binary or labelled</span>
            <span class="n">s_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">s_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">s_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># binary source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># labelled source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_w_source_correction_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether to use the w source correction instead of the k-space source correction for pressure sources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_frequency_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_w_source_correction_u</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Whether to use the w source correction instead of the k-space source correction for velocity sources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">,</span> <span class="s1">&#39;uy&#39;</span><span class="p">,</span> <span class="s1">&#39;uz&#39;</span><span class="p">,</span> <span class="s1">&#39;u_mask&#39;</span><span class="p">]]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_frequency_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

<div class="viewcode-block" id="kWaveSimulation.input_checking"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.input_checking">[docs]</a>    <span class="k">def</span> <span class="nf">input_checking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calling_func_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check the input fields for correctness and validness</span>

<span class="sd">        Args:</span>
<span class="sd">            calling_func_name: Name of the script that calls this function</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span> <span class="o">=</span> <span class="n">calling_func_name</span>

        <span class="n">k_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">k_Nx</span><span class="p">,</span> <span class="n">k_Ny</span><span class="p">,</span> <span class="n">k_Nz</span><span class="p">,</span> <span class="n">k_Nt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_calling_func_name_and_dim</span><span class="p">(</span><span class="n">calling_func_name</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">)</span>

        <span class="c1"># run subscript to check optional inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">SimulationOptions</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span>

        <span class="n">pml_x_size</span><span class="p">,</span> <span class="n">pml_y_size</span><span class="p">,</span> <span class="n">pml_z_size</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_x_size</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_y_size</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_z_size</span>
        <span class="n">pml_size</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">pml_x_size</span><span class="p">,</span> <span class="n">pml_y_size</span><span class="p">,</span> <span class="n">pml_z_size</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_start_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_index_data_type</span><span class="p">()</span>

        <span class="n">user_medium_density_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_medium</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">)</span>

        <span class="c1"># select the reference sound speed used in the k-space operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_compression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_shear</span> \
            <span class="o">=</span> <span class="n">set_sound_speed_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kspace_elastic_code</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_source</span><span class="p">(</span><span class="n">k_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_sensor</span><span class="p">(</span><span class="n">k_dim</span><span class="p">,</span> <span class="n">k_Nt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_kgrid_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_precision</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_input_combinations</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="n">user_medium_density_input</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># run subscript to display time step, max supported frequency etc.</span>
        <span class="n">display_simulation_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smooth_and_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_sensor_variables</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_absorption_vars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_pseudonyms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_source_terms</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">scale_source_terms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_pml_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_calling_func_name_and_dim"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_calling_func_name_and_dim">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_calling_func_name_and_dim</span><span class="p">(</span><span class="n">calling_func_name</span><span class="p">,</span> <span class="n">kgrid_dim</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check correct function has been called for the dimensionality of kgrid</span>

<span class="sd">        Args:</span>
<span class="sd">            calling_func_name: Name of the script that makes calls to kWaveSimulation</span>
<span class="sd">            kgrid_dim: Dimensionality of the kWaveGrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;pstdElastic&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic&#39;</span><span class="p">)),</span> \
            <span class="s2">&quot;Elastic simulation is not supported.&quot;</span>

        <span class="k">if</span> <span class="n">calling_func_name</span> <span class="o">==</span> <span class="s1">&#39;kspaceFirstOrder1D&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kgrid has the wrong dimensionality for </span><span class="si">{</span><span class="n">calling_func_name</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="k">elif</span> <span class="n">calling_func_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kspaceFirstOrder2D&#39;</span><span class="p">,</span> <span class="s1">&#39;pstdElastic2D&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic2D&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceFirstOrderAS&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kgrid has the wrong dimensionality for </span><span class="si">{</span><span class="n">calling_func_name</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="k">elif</span> <span class="n">calling_func_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kspaceFirstOrder3D&#39;</span><span class="p">,</span> <span class="s1">&#39;pstdElastic3D&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic3D&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kgrid has the wrong dimensionality for </span><span class="si">{</span><span class="n">calling_func_name</span><span class="si">}</span><span class="s1">.&#39;</span></div>

<div class="viewcode-block" id="kWaveSimulation.print_start_status"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.print_start_status">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">print_start_status</span><span class="p">(</span><span class="n">is_elastic_code</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Update command-line status with the start time</span>

<span class="sd">        Args:</span>
<span class="sd">            is_elastic_code: is the simulation elastic</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_elastic_code</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running k-Wave elastic simulation...&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running k-Wave simulation...&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  start time: </span><span class="si">{</span><span class="n">get_date_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.set_index_data_type"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.set_index_data_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_index_data_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pre-calculate the data type needed to store the matrix indices given the</span>
<span class="sd">            total number of grid points: indexing variables will be created using this data type to save memory</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_grid_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">total_grid_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span> <span class="o">=</span> <span class="n">get_smallest_possible_type</span><span class="p">(</span><span class="n">total_grid_points</span><span class="p">,</span> <span class="s1">&#39;uint&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_medium"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_medium">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_medium</span><span class="p">(</span><span class="n">medium</span><span class="p">,</span> <span class="n">kgrid_k</span><span class="p">,</span> <span class="n">is_elastic</span><span class="p">,</span> <span class="n">is_axisymmetric</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check the properties of the medium structure for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            medium: kWaveMedium instance</span>
<span class="sd">            kgrid_k: kWaveGrid.k matrix</span>
<span class="sd">            is_elastic: Whether the simulation is elastic</span>
<span class="sd">            is_axisymmetric: Whether the simulation is axisymmetric</span>

<span class="sd">        Returns:</span>
<span class="sd">            Medium Density</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if using the fluid code, allow the density field to be blank if the medium is homogeneous</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_elastic</span> <span class="ow">and</span> <span class="n">medium</span><span class="o">.</span><span class="n">density</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">user_medium_density_input</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">medium</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">medium</span><span class="o">.</span><span class="n">ensure_defined</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
            <span class="n">user_medium_density_input</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># check medium absorption inputs for the fluid code</span>
        <span class="n">is_absorbing</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">medium</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s1">&#39;alpha_coeff&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha_power&#39;</span><span class="p">))</span>
        <span class="n">is_stokes</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_axisymmetric</span> <span class="ow">or</span> <span class="n">medium</span><span class="o">.</span><span class="n">alpha_mode</span> <span class="o">==</span> <span class="s1">&#39;stokes&#39;</span><span class="p">)</span>
        <span class="n">medium</span><span class="o">.</span><span class="n">set_absorbing</span><span class="p">(</span><span class="n">is_absorbing</span><span class="p">,</span> <span class="n">is_stokes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_absorbing</span><span class="p">:</span>
            <span class="n">medium</span><span class="o">.</span><span class="n">check_fields</span><span class="p">(</span><span class="n">kgrid_k</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">user_medium_density_input</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_source"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_source">[docs]</a>    <span class="k">def</span> <span class="nf">check_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kgrid_dim</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check the source properties for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            kgrid_dim: kWaveGrid dimension</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># CHECK SENSOR STRUCTURE INPUTS</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># check sensor fields</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># check the sensor input is valid</span>
            <span class="c1"># TODO FARID move this check as a type checking</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="p">(</span><span class="n">kSensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)),</span> \
                <span class="s1">&#39;sensor must be defined as an object of the kSensor or kWaveTransducer class.&#39;</span>

            <span class="c1"># check if sensor is a transducer, otherwise check input fields</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

                    <span class="c1"># check field names, including the directivity inputs for the</span>
                    <span class="c1"># regular 2D code, but not the axisymmetric code</span>
                    <span class="c1"># TODO question to Walter: we do not need following checks anymore because we have kSensor that defines the structure, right?</span>
                    <span class="c1"># if self.axisymmetric:</span>
                    <span class="c1">#     check_field_names(self.sensor, *[&#39;mask&#39;, &#39;time_reversal_boundary_data&#39;, &#39;frequency_response&#39;,</span>
                    <span class="c1">#                                        &#39;record_mode&#39;, &#39;record&#39;, &#39;record_start_index&#39;])</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     check_field_names(self.sensor, *[&#39;mask&#39;, &#39;directivity&#39;, &#39;time_reversal_boundary_data&#39;,</span>
                    <span class="c1">#                                      &#39;frequency_response&#39;, &#39;record_mode&#39;, &#39;record&#39;, &#39;record_start_index&#39;])</span>

                    <span class="c1"># check for sensor directivity input and set flag</span>
                    <span class="n">directivity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">directivity</span>
                    <span class="k">if</span> <span class="n">directivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">directivity</span><span class="o">.</span><span class="n">angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                        <span class="c1"># make sure the sensor mask is not blank</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;The mask must be defined for the sensor&#39;</span>

                        <span class="c1"># check sensor.directivity.pattern and sensor.mask have the same size</span>
                        <span class="k">assert</span> <span class="n">directivity</span><span class="o">.</span><span class="n">angle</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> \
                            <span class="s1">&#39;sensor.directivity.angle and sensor.mask must be the same size.&#39;</span>

                        <span class="c1"># check if directivity size input exists, otherwise make it</span>
                        <span class="c1"># a constant times kgrid.dx</span>
                        <span class="k">if</span> <span class="n">directivity</span><span class="o">.</span><span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">directivity</span><span class="o">.</span><span class="n">set_default_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>

                        <span class="c1"># find the unique directivity angles</span>
                        <span class="c1"># assign the wavenumber vectors</span>
                        <span class="n">directivity</span><span class="o">.</span><span class="n">set_unique_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
                        <span class="n">directivity</span><span class="o">.</span><span class="n">set_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># TODO question to Walter: we do not need following checks anymore because we have kSensor that defines the structure, right?</span>
                    <span class="c1"># check field names without directivity inputs (these are not supported in 1 or 3D)</span>
                    <span class="c1"># check_field_names(self.sensor, *[&#39;mask&#39;, &#39;time_reversal_boundary_data&#39;, &#39;frequency_response&#39;,</span>
                    <span class="c1">#                                    &#39;record_mode&#39;, &#39;record&#39;, &#39;record_start_index&#39;])</span>
                    <span class="k">pass</span>

                <span class="c1"># check for time reversal inputs and set flgs</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">time_reversal_boundary_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># check for sensor.record and set usage flgs - if no flgs are</span>
                <span class="c1"># given, the time history of the acoustic pressure is recorded by</span>
                <span class="c1"># default</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="c1"># check for time reversal data</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: sensor.record is not used for time reversal reconstructions&#39;</span><span class="p">)</span>

                    <span class="c1"># check the input is a cell array</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s1">&#39;sensor.record must be given as a list, e.g. [&quot;p&quot;, &quot;u&quot;]&#39;</span>

                    <span class="c1"># check the sensor record flgs</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">set_flags_from_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">)</span>

                <span class="c1"># enforce the sensor.mask field unless just recording the max_all</span>
                <span class="c1"># and _final variables</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p_max&#39;</span><span class="p">,</span> <span class="s1">&#39;p_min&#39;</span><span class="p">,</span> <span class="s1">&#39;p_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;u_non_staggered&#39;</span><span class="p">,</span> <span class="s1">&#39;u_split_field&#39;</span><span class="p">,</span> <span class="s1">&#39;u_max&#39;</span><span class="p">,</span> <span class="s1">&#39;u_min&#39;</span><span class="p">,</span> <span class="s1">&#39;u_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;I_avg&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="n">fields</span><span class="p">)):</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="c1"># check if sensor mask is a binary grid, a set of cuboid corners,</span>
                <span class="c1"># or a set of Cartesian interpolation points</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">kgrid_dim</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>

                        <span class="c1"># check the grid is binary</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span> \
                            <span class="s1">&#39;sensor.mask must be a binary grid (numeric values must be 0 or 1).&#39;</span>

                        <span class="c1"># check the grid is not empty</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;sensor.mask must be a binary grid with at least one element set to 1.&#39;</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">kgrid_dim</span><span class="p">:</span>

                        <span class="c1"># make sure the points are integers</span>
                        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;sensor.mask cuboid corner indices must be integers.&#39;</span>

                        <span class="c1"># store a copy of the cuboid corners</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span>

                        <span class="c1"># check the list makes sense</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be defined as [x1, x2; ...].&#39;&#39; where x2 =&gt; x1, etc.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be defined as [x1, y1, x2, y2; ...].&#39;&#39; where x2 =&gt; x1, etc.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be defined as [x1, y1, z1, x2, y2, z2; ...].&#39;&#39; where x2 =&gt; x1, etc.&#39;</span><span class="p">)</span>

                        <span class="c1"># check the list are within bounds</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">)</span> <span class="ow">or</span> \
                                        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">)</span> <span class="ow">or</span> \
                                        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nz</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>

                        <span class="c1"># create a binary mask for display from the list of corners</span>
                        <span class="c1"># TODO FARID mask should be init in sensor not here</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cuboid_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># check the Cartesian sensor mask is the correct size</span>
                        <span class="c1"># (1 x N, 2 x N, 3 x N)</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">kgrid_dim</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> \
                            <span class="sa">f</span><span class="s1">&#39;Cartesian sensor.mask for a </span><span class="si">{</span><span class="n">kgrid_dim</span><span class="si">}</span><span class="s1">D simulation must be given as a </span><span class="si">{</span><span class="n">kgrid_dim</span><span class="si">}</span><span class="s1"> by N array.&#39;</span>

                        <span class="c1"># set Cartesian mask flag (this is modified in</span>
                        <span class="c1"># createStorageVariables if the interpolation setting is</span>
                        <span class="c1"># set to nearest)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span> <span class="o">=</span> <span class="kc">False</span>

                        <span class="c1"># extract Cartesian data from sensor mask</span>
                        <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># align sensor data as a column vector to be the</span>
                            <span class="c1"># same as kgrid.x_vec so that calls to interp1</span>
                            <span class="c1"># return data in the correct dimension</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

                            <span class="c1"># add sensor_x to the record structure for use with</span>
                            <span class="c1"># the _extractSensorData subfunction</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span>
                            <span class="s2">&quot;record.sensor_x = sensor_x;&quot;</span>

                        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

                        <span class="c1"># compute an equivalent sensor mask using nearest neighbour</span>
                        <span class="c1"># interpolation, if flgs.time_rev = false and</span>
                        <span class="c1"># cartesian_interp = &#39;linear&#39; then this is only used for</span>
                        <span class="c1"># display, if flgs.time_rev = true or cartesian_interp =</span>
                        <span class="c1"># &#39;nearest&#39; this grid is used as the sensor.mask</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_index</span> <span class="o">=</span> <span class="n">cart2grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">)</span>

                        <span class="c1"># if in time reversal mode, reorder the p0 input data in</span>
                        <span class="c1"># the order of the binary sensor_mask</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            # append the reordering data</span>
<span class="sd">                            new_col_pos = length(sensor.time_reversal_boundary_data(1, :)) + 1;</span>
<span class="sd">                            sensor.time_reversal_boundary_data(:, new_col_pos) = order_index;</span>
<span class="sd">        </span>
<span class="sd">                            # reorder p0 based on the order_index</span>
<span class="sd">                            sensor.time_reversal_boundary_data = sortrows(sensor.time_reversal_boundary_data, new_col_pos);</span>
<span class="sd">        </span>
<span class="sd">                            # remove the reordering data</span>
<span class="sd">                            sensor.time_reversal_boundary_data = sensor.time_reversal_boundary_data(:, 1:new_col_pos - 1);</span>
<span class="sd">                            &quot;&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set transducer sensor flag</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_sensor</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># check to see if there is an elevation focus</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">elevation_focus_distance</span><span class="p">):</span>
                    <span class="c1"># set flag</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># get the elevation mask that is used to extract the correct values</span>
                    <span class="c1"># from the sensor data buffer for averaging</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">elevation_beamforming_mask</span>

        <span class="c1"># check for directivity inputs with time reversal</span>
        <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_directivity</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: sensor directivity fields are not used for time reversal.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_sensor"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_sensor">[docs]</a>    <span class="k">def</span> <span class="nf">check_sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">k_Nt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check the Sensor properties for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            k_dim: kWaveGrid dimensionality</span>
<span class="sd">            k_Nt: Number of time steps in kWaveGrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># CHECK SOURCE STRUCTURE INPUTS</span>
        <span class="c1"># =========================================================================</span>

        <span class="c1"># check source inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="p">(</span><span class="n">kSource</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)):</span>
            <span class="c1"># allow an invalid or empty source input if computing time reversal,</span>
            <span class="c1"># otherwise return error</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">,</span> <span class="s1">&#39;source must be defined as an object of the kSource or kWaveTransducer classes.&#39;</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>

            <span class="c1"># --------------------------</span>
            <span class="c1"># SOURCE IS NOT A TRANSDUCER</span>
            <span class="c1"># --------------------------</span>

            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                check allowable source types</span>
<span class="sd">                </span>
<span class="sd">                Depending on the kgrid dimensionality and the simulation type, </span>
<span class="sd">                    following fields are allowed &amp; might be use:</span>
<span class="sd">                </span>
<span class="sd">                kgrid.dim == 1:</span>
<span class="sd">                    non-elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;p&#39;, &#39;p_mask&#39;, &#39;p_mode&#39;, &#39;p_frequency_ref&#39;, &#39;ux&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;, &#39;u_frequency_ref&#39;]</span>
<span class="sd">                kgrid.dim == 2:</span>
<span class="sd">                    non-elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;p&#39;, &#39;p_mask&#39;, &#39;p_mode&#39;, &#39;p_frequency_ref&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;, &#39;u_frequency_ref&#39;]</span>
<span class="sd">                    elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;sxx&#39;, &#39;syy&#39;, &#39;sxy&#39;, &#39;s_mask&#39;, &#39;s_mode&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;]</span>
<span class="sd">                kgrid.dim == 3:</span>
<span class="sd">                    non-elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;p&#39;, &#39;p_mask&#39;, &#39;p_mode&#39;, &#39;p_frequency_ref&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;uz&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;, &#39;u_frequency_ref&#39;]</span>
<span class="sd">                    elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;sxx&#39;, &#39;syy&#39;, &#39;szz&#39;, &#39;sxy&#39;, &#39;sxz&#39;, &#39;syz&#39;, &#39;s_mask&#39;, &#39;s_mode&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;uz&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;]</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>

            <span class="c1"># check for a time varying pressure source input</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># check the source mode input is valid</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_P_MODE_DEF</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span> <span class="o">&gt;</span> <span class="n">k_Nt</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;  WARNING: source.p has more time points than kgrid.Nt, remaining time points will not be used.&#39;</span><span class="p">)</span>

                <span class="c1"># create an indexing variable corresponding to the location of all the source elements</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">)</span>

                <span class="c1"># check if the mask is binary or labelled</span>
                <span class="n">p_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">)</span>

                <span class="c1"># create a second indexing variable</span>
                <span class="k">if</span> <span class="n">p_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">p_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># set signal index to all elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set signal index to the labels (this allows one input signal</span>
                    <span class="c1"># to be used for each source label)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># convert the data type depending on the number of indices</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p_labelled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="c1"># check for time varying velocity source input and set source flag</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">,</span> <span class="s1">&#39;uy&#39;</span><span class="p">,</span> <span class="s1">&#39;uz&#39;</span><span class="p">,</span> <span class="s1">&#39;u_mask&#39;</span><span class="p">]]):</span>

                <span class="c1"># check the source mode input is valid</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_U_MODE_DEF</span>

                <span class="c1"># create an indexing variable corresponding to the location of all</span>
                <span class="c1"># the source elements</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">)</span>

                <span class="c1"># check if the mask is binary or labelled</span>
                <span class="n">u_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">)</span>

                <span class="c1"># create a second indexing variable</span>
                <span class="k">if</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="c1"># set signal index to all elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set signal index to the labels (this allows one input signal</span>
                    <span class="c1"># to be used for each source label)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># convert the data type depending on the number of indices</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_u_labelled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="c1"># check for time varying stress source input and set source flag</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sxx&#39;</span><span class="p">,</span> <span class="s1">&#39;syy&#39;</span><span class="p">,</span> <span class="s1">&#39;szz&#39;</span><span class="p">,</span> <span class="s1">&#39;sxy&#39;</span><span class="p">,</span> <span class="s1">&#39;sxz&#39;</span><span class="p">,</span> <span class="s1">&#39;syz&#39;</span><span class="p">,</span> <span class="s1">&#39;s_mask&#39;</span><span class="p">]]):</span>
                <span class="c1"># create an indexing variable corresponding to the location of all</span>
                <span class="c1"># the source elements</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="s1">&#39;s_source_pos_index = find(source.s_mask != 0);&#39;</span>

                <span class="c1"># check if the mask is binary or labelled</span>
                <span class="s1">&#39;s_unique = unique(source.s_mask);&#39;</span>

                <span class="c1"># create a second indexing variable</span>
                <span class="k">if</span> <span class="n">eng</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;numel(s_unique) &lt;= 2 &amp;&amp; sum(s_unique) == 1&#39;</span><span class="p">):</span>
                    <span class="c1"># set signal index to all elements</span>
                    <span class="n">eng</span><span class="o">.</span><span class="n">workspace</span><span class="p">[</span><span class="s1">&#39;s_source_sig_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set signal index to the labels (this allows one input signal</span>
                    <span class="c1"># to be used for each source label)</span>
                    <span class="n">s_source_sig_index</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">s_mask</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">s_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

                <span class="sa">f</span><span class="s1">&#39;s_source_pos_index = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="si">}</span><span class="s1">(s_source_pos_index);&#39;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_s_labelled</span><span class="p">:</span>
                    <span class="sa">f</span><span class="s1">&#39;s_source_sig_index = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="si">}</span><span class="s1">(s_source_sig_index);&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ----------------------</span>
            <span class="c1"># SOURCE IS A TRANSDUCER</span>
            <span class="c1"># ----------------------</span>

            <span class="c1"># if the sensor is a transducer, check that the simulation is in 3D</span>
            <span class="k">assert</span> <span class="n">k_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Transducer inputs are only compatible with 3D simulations.&#39;</span>

            <span class="c1"># get the input signal - this is appended with zeros if required to</span>
            <span class="c1"># account for the beamforming delays (this will throw an error if the</span>
            <span class="c1"># input signal is not defined)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">input_signal</span>

            <span class="c1"># get the delay mask that accounts for the beamforming delays and</span>
            <span class="c1"># elevation focussing; this is used so that a single time series can be</span>
            <span class="c1"># applied to the complete transducer mask with different delays</span>
            <span class="n">delay_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">delay_mask</span><span class="p">()</span>

            <span class="c1"># set source flag - this should be the length of signal minus the</span>
            <span class="c1"># maximum delay</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">delay_mask</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># get the active elements mask</span>
            <span class="n">active_elements_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">active_elements_mask</span>

            <span class="c1"># get the apodization mask if not set to &#39;Rectangular&#39; and convert to a</span>
            <span class="c1"># linear array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">transmit_apodization</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">transmit_apodization_mask</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span><span class="p">[</span><span class="n">active_elements_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># create indexing variable corresponding to the active elements</span>
            <span class="c1"># and convert the data type depending on the number of indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">active_elements_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="c1"># convert the delay mask to an indexing variable (this doesn&#39;t need to</span>
            <span class="c1"># be modified if the grid is expanded) which tells each point in the</span>
            <span class="c1"># source mask which point in the input_signal should be used</span>
            <span class="n">delay_mask</span> <span class="o">=</span> <span class="n">matlab_mask</span><span class="p">(</span><span class="n">delay_mask</span><span class="p">,</span> <span class="n">active_elements_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># compatibility</span>

            <span class="c1"># convert the data type depending on the maximum value of the delay</span>
            <span class="c1"># mask and the length of the source</span>
            <span class="n">smallest_type</span> <span class="o">=</span> <span class="n">get_smallest_possible_type</span><span class="p">(</span><span class="n">delay_mask</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="s1">&#39;uint&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">smallest_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">delay_mask</span> <span class="o">=</span> <span class="n">delay_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">smallest_type</span><span class="p">)</span>

            <span class="c1"># move forward by 1 as a delay of 0 corresponds to the first point in the input signal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delay_mask</span> <span class="o">=</span> <span class="n">delay_mask</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># clean up unused variables</span>
            <span class="k">del</span> <span class="n">active_elements_mask</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_kgrid_time"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_kgrid_time">[docs]</a>    <span class="k">def</span> <span class="nf">check_kgrid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check time-related kWaveGrid inputs</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check kgrid for t_array existance, and create if not defined</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">t_array</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">t_array</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>

            <span class="c1"># check for time reversal mode</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kgrid.t_array (Nt and dt) must be defined explicitly in time reversal mode.&#39;</span><span class="p">)</span>

            <span class="c1"># check for time varying sources</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0_elastic</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_sxx</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_szz</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_sxy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxz</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syz</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kgrid.t_array (Nt and dt) must be defined explicitly when using a time-varying source.&#39;</span><span class="p">)</span>

            <span class="c1"># create the time array using the compressional sound speed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">makeTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">KSPACE_CFL</span><span class="p">)</span>

        <span class="c1"># check kgrid.t_array for stability given medium properties</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">:</span>

            <span class="c1"># calculate the largest timestep for which the model is stable</span>

            <span class="n">dt_stability_limit</span> <span class="o">=</span> <span class="n">check_stability</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">)</span>

            <span class="c1"># give a warning if the timestep is larger than stability limit allows</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="n">dt_stability_limit</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;  WARNING: time step may be too large for a stable simulation.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.select_precision"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.select_precision">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">select_precision</span><span class="p">(</span><span class="n">opt</span><span class="p">:</span> <span class="n">SimulationOptions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Select the minimal precision for storing the data</span>

<span class="sd">        Args:</span>
<span class="sd">            opt: SimulationOptions instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            Minimal precision for variable allocation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set storage variable type based on data_cast - this enables the</span>
        <span class="c1"># output variables to be directly created in the data_cast format,</span>
        <span class="c1"># rather than creating them in double precision and then casting them</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;off&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;gsingle&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;gdouble&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;gpuArray&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;gpuArray is not supported in Python-version&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;kWaveGPUsingle&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;kWaveGPUdouble&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;Unknown &#39;&#39;DataCast&#39;&#39; option&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">precision</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_input_combinations"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_input_combinations">[docs]</a>    <span class="k">def</span> <span class="nf">check_input_combinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="n">SimulationOptions</span><span class="p">,</span> <span class="n">user_medium_density_input</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check the input combinations for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            opt: SimulationOptions instance</span>
<span class="sd">            user_medium_density_input: Medium Density</span>
<span class="sd">            k_dim: kWaveGrid dimensionality</span>
<span class="sd">            pml_size: Size of the PML</span>
<span class="sd">            kgrid_N: kWaveGrid size in each direction</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># CHECK FOR VALID INPUT COMBINATIONS</span>
        <span class="c1"># =========================================================================</span>

        <span class="c1"># enforce density input if velocity sources or output are being used</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">user_medium_density_input</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u_max</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u_rms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;medium.density must be explicitly defined if velocity inputs or outputs are used, even in homogeneous media.&#39;</span><span class="p">)</span>

        <span class="c1"># enforce density input if nonlinear equations are being used</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">user_medium_density_input</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">is_nonlinear</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;medium.density must be explicitly defined if medium.BonA is specified.&#39;</span><span class="p">)</span>

        <span class="c1"># check sensor compatability options for flgs.compute_directivity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="n">k_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_directivity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span> <span class="ow">and</span> <span class="n">opt</span><span class="o">.</span><span class="n">cartesian_interp</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor directivity fields are only compatible with binary sensor masks or &#39;&#39;CartInterp&#39;&#39; set to &#39;&#39;nearest&#39;&#39;.&#39;</span><span class="p">)</span>

        <span class="c1"># check for split velocity output</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u_split_field</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The option sensor.record = {&#39;&#39;u_split_field&#39;&#39;} is only compatible with a binary sensor mask.&#39;</span><span class="p">)</span>

        <span class="c1"># check input options for data streaming *****</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">stream_to_disk</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The optional input &#39;&#39;StreamToDisk&#39;&#39; is currently only compatible with forward simulations using a non-zero sensor mask.&#39;</span><span class="p">);</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">ismember</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The optional input &#39;&#39;StreamToDisk&#39;&#39; is currently only compatible with sensor.record = {&#39;&#39;p&#39;&#39;} (the default).&#39;</span><span class="p">)</span>

        <span class="c1"># make sure the PML size is smaller than the grid if PMLInside is true</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">)))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The size of the PML must be smaller than the size of the grid.&#39;</span><span class="p">)</span>

        <span class="c1"># make sure the PML is inside if using a non-uniform grid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonuniform_grid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;&#39;PMLInside&#39;&#39; must be true for simulations using non-uniform grids.&quot;</span><span class="p">)</span>

        <span class="c1"># check for compatible input options if saving to disk</span>
        <span class="c1"># modified by Farid | disabled temporarily!</span>
        <span class="c1"># if k_dim == 3 and isinstance(self.options.save_to_disk, str) and (not self.use_sensor or not self.binary_sensor_mask or self.time_rev):</span>
        <span class="c1">#     raise ValueError(&#39;The optional input &#39;&#39;SaveToDisk&#39;&#39; is currently only compatible with forward simulations using a non-zero binary sensor mask.&#39;)</span>

        <span class="c1"># check the record start time is within range</span>
        <span class="n">record_start_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record_start_index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="p">((</span><span class="n">record_start_index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">record_start_index</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.record_start_index must be between 1 and the number of time steps.&#39;</span><span class="p">)</span>

        <span class="c1"># ensure &#39;WSWA&#39; symmetry if using axisymmetric code with &#39;SaveToDisk&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="o">!=</span> <span class="s1">&#39;WSWA&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="c1"># display a warning only if using WSWS symmetry (not WSWA-FFT)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;WSWS&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  WARNING: Optional input &#39;&#39;RadialSymmetry&#39;&#39; changed to &#39;&#39;WSWA&#39;&#39; for compatability with &#39;&#39;SaveToDisk&#39;&#39;.&#39;</span><span class="p">)</span>

            <span class="c1"># update setting</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="o">=</span> <span class="s1">&#39;WSWA&#39;</span>

        <span class="c1"># ensure p0 smoothing is switched off if p0 is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">smooth_p0</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># start log if required</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">create_log</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;diary(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">LOG_NAME</span><span class="si">}</span><span class="s2">.txt&#39;);&quot;</span><span class="p">)</span>

        <span class="c1"># update command line status</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  time reversal mode&#39;</span><span class="p">)</span>

        <span class="c1"># cleanup unused variables</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_DEF&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.smooth_and_enlarge"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.smooth_and_enlarge">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_and_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="n">SimulationOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Smooth and enlarge grids</span>

<span class="sd">        Args:</span>
<span class="sd">            source: kWaveSource instance</span>
<span class="sd">            k_dim: kWaveGrid dimensionality</span>
<span class="sd">            kgrid_N: kWaveGrid size in each direction</span>
<span class="sd">            opt: SimulationOptions</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># smooth the initial pressure distribution p0 if required, and then restore</span>
        <span class="c1"># the maximum magnitude</span>
        <span class="c1">#   NOTE 1: if p0 has any values at the edge of the domain, the smoothing</span>
        <span class="c1">#   may cause part of p0 to wrap to the other side of the domain</span>
        <span class="c1">#   NOTE 2: p0 is smoothed before the grid is expanded to ensure that p0 is</span>
        <span class="c1">#   exactly zero within the PML</span>
        <span class="c1">#   NOTE 3: for the axisymmetric code, p0 is smoothed assuming WS origin</span>
        <span class="c1">#   symmetry</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">smooth_p0</span><span class="p">:</span>

            <span class="c1"># update command line status</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  smoothing p0 distribution...&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;WSWA-FFT&#39;</span><span class="p">,</span> <span class="s1">&#39;WSWA&#39;</span><span class="p">]:</span>
                    <span class="c1"># create a new kWave grid object with expanded radial grid</span>
                    <span class="n">kgrid_exp</span> <span class="o">=</span> <span class="n">kWaveGrid</span><span class="p">([</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dy</span><span class="p">])</span>

                    <span class="c1"># mirror p0 in radial dimension using WSWA symmetry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">p0_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> <span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Ny</span><span class="p">))</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>           <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;WSWS-FFT&#39;</span><span class="p">,</span> <span class="s1">&#39;WSWS&#39;</span><span class="p">]:</span>
                    <span class="c1"># create a new kWave grid object with expanded radial grid</span>
                    <span class="n">kgrid_exp</span> <span class="o">=</span> <span class="n">kWaveGrid</span><span class="p">([</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dy</span><span class="p">])</span>

                    <span class="c1"># mirror p0 in radial dimension using WSWS symmetry</span>
                    <span class="n">p0_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> <span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Ny</span><span class="p">))</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>              <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">p0</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># smooth p0</span>
                <span class="n">p0_exp</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">p0_exp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

                <span class="c1"># trim back to original size</span>
                <span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">p0_exp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">]</span>

                <span class="c1"># clean up unused variables</span>
                <span class="k">del</span> <span class="n">kgrid_exp</span>
                <span class="k">del</span> <span class="n">p0_exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># expand the computational grid if the PML is set to be outside the input</span>
        <span class="c1"># grid defined by the user</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span><span class="p">:</span>
            <span class="n">expand_results</span> <span class="o">=</span> <span class="n">expand_grid_matrices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;p_source_pos_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span><span class="p">,</span>
                    <span class="s1">&#39;u_source_pos_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span><span class="p">,</span>
                    <span class="s1">&#39;s_source_pos_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;axisymmetric&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">,</span>
                    <span class="s1">&#39;use_sensor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span><span class="p">,</span>
                    <span class="s1">&#39;blank_sensor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span><span class="p">,</span>
                    <span class="s1">&#39;cuboid_corners&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuboid_corners</span><span class="p">,</span>

                    <span class="s1">&#39;source_p0&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span><span class="p">,</span>
                    <span class="s1">&#39;source_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span><span class="p">,</span>

                    <span class="s1">&#39;source_ux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span><span class="p">,</span>
                    <span class="s1">&#39;source_uy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span><span class="p">,</span>
                    <span class="s1">&#39;source_uz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span><span class="p">,</span>

                    <span class="s1">&#39;transducer_source&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span><span class="p">,</span>

                    <span class="s1">&#39;source_sxx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxx</span><span class="p">,</span>
                    <span class="s1">&#39;source_syy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syy</span><span class="p">,</span>
                    <span class="s1">&#39;source_szz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_szz</span><span class="p">,</span>
                    <span class="s1">&#39;source_sxy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxy</span><span class="p">,</span>
                    <span class="s1">&#39;source_sxz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxz</span><span class="p">,</span>
                    <span class="s1">&#39;source_syz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syz</span>
                <span class="p">})</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="n">expand_results</span>

        <span class="c1"># get maximum prime factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">:</span>
            <span class="n">prime_facs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">highest_prime_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prime_facs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">highest_prime_factors</span><span class="p">()</span>

        <span class="c1"># give warning for bad dimension sizes</span>
        <span class="k">if</span> <span class="n">prime_facs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">HIGHEST_PRIME_FACTOR_WARNING</span><span class="p">:</span>
            <span class="n">prime_facs</span> <span class="o">=</span> <span class="n">prime_facs</span><span class="p">[</span><span class="n">prime_facs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: Highest prime factors in each dimension are </span><span class="si">{</span><span class="n">prime_facs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Use dimension sizes with lower prime factors to improve speed&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">prime_facs</span>

        <span class="c1"># smooth the sound speed distribution if required</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">smooth_c0</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="p">)</span> <span class="o">==</span> <span class="n">k_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  smoothing sound speed distribution...&#39;</span><span class="p">)</span>
            <span class="n">ev</span><span class="p">(</span><span class="s1">&#39;medium.sound_speed = smooth(medium.sound_speed);&#39;</span><span class="p">)</span>

        <span class="c1"># smooth the ambient density distribution if required</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">smooth_rho0</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">density</span><span class="p">)</span> <span class="o">==</span> <span class="n">k_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">density</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;smoothing density distribution...&#39;</span><span class="p">)</span>
            <span class="n">ev</span><span class="p">(</span><span class="s1">&#39;medium.density = smooth(medium.density);&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.create_sensor_variables"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.create_sensor_variables">[docs]</a>    <span class="k">def</span> <span class="nf">create_sensor_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Create the sensor related variables</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define the output variables and mask indices if using the sensor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuboid_corners</span><span class="p">:</span>

                    <span class="c1"># create empty list of sensor indices</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="c1"># loop through the list of cuboid corners, and extract the</span>
                    <span class="c1"># sensor mask indices for each cube</span>
                    <span class="k">for</span> <span class="n">cuboid_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>

                        <span class="c1"># create empty binary mask</span>
                        <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="c1"># extract mask indices</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matlab_find</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">)</span>

                    <span class="c1"># cleanup unused variables</span>
                    <span class="k">del</span> <span class="n">temp_mask</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># create mask indices (this works for both normal sensor and</span>
                    <span class="c1"># transducer inputs)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 due to matlab indexing</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># compatibility, n =&gt; [n, 1]</span>

                <span class="c1"># convert the data type depending on the number of indices (this saves</span>
                <span class="c1"># memory)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set the sensor mask index variable to be empty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># run subscript to create storage variables if not saving to disk</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">create_storage_variables</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;binary_sensor_mask&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span><span class="p">,</span>
                    <span class="s1">&#39;time_rev&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">,</span>
                    <span class="s1">&#39;blank_sensor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span><span class="p">,</span>
                    <span class="s1">&#39;record_u_split_field&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_u_split_field</span><span class="p">,</span>
                    <span class="s1">&#39;source_u_labelled&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_u_labelled</span><span class="p">,</span>
                    <span class="s1">&#39;axisymmetric&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">,</span>
                    <span class="s1">&#39;reorder_data&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_data</span><span class="p">,</span>
                    <span class="s1">&#39;transducer_receive_elevation_focus&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;sensor_x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span><span class="p">,</span>
                    <span class="s1">&#39;sensor_mask_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">,</span>
                    <span class="s1">&#39;record&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">,</span>
                    <span class="s1">&#39;sensor_data_buffer_size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor_data_buffer_size</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span>                 <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">binary_sensor_mask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_data</span>                       <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reorder_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span></div>

<div class="viewcode-block" id="kWaveSimulation.create_absorption_vars"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.create_absorption_vars">[docs]</a>    <span class="k">def</span> <span class="nf">create_absorption_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Create absorption variables for the fluid code based on</span>
<span class="sd">            the expanded and smoothed values of the medium parameters (if not saving to disk)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorb_tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorb_eta</span> <span class="o">=</span> <span class="n">create_absorption_variables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_of_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.assign_pseudonyms"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.assign_pseudonyms">[docs]</a>    <span class="k">def</span> <span class="nf">assign_pseudonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">medium</span><span class="p">:</span> <span class="n">kWaveMedium</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">:</span> <span class="n">kWaveGrid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Shorten commonly used field names (these act only as pointers provided that the values aren&#39;t modified)</span>
<span class="sd">            (done after enlarging and smoothing the grids)</span>

<span class="sd">        Args:</span>
<span class="sd">            medium: kWaveMedium instance</span>
<span class="sd">            kgrid: kWaveGrid instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span> <span class="o">=</span> <span class="n">medium</span><span class="o">.</span><span class="n">density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c0</span> <span class="o">=</span> <span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span></div>

<div class="viewcode-block" id="kWaveSimulation.scale_source_terms"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.scale_source_terms">[docs]</a>    <span class="k">def</span> <span class="nf">scale_source_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_scale_source_terms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Scale the source terms based on the expanded and smoothed values of the medium parameters</span>

<span class="sd">        Args:</span>
<span class="sd">            is_scale_source_terms: Should the source terms be scaled</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scale_source_terms</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span> <span class="o">=</span> <span class="n">scale_source_terms_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
            <span class="n">p_source_pos_index</span><span class="p">,</span> <span class="n">s_source_pos_index</span><span class="p">,</span> <span class="n">u_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span><span class="p">,</span>
            <span class="n">dotdict</span><span class="p">({</span>
                <span class="s1">&#39;nonuniform_grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonuniform_grid</span><span class="p">,</span>
                <span class="s1">&#39;source_ux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span><span class="p">,</span>
                <span class="s1">&#39;source_uy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span><span class="p">,</span>
                <span class="s1">&#39;source_uz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span><span class="p">,</span>
                <span class="s1">&#39;transducer_source&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span><span class="p">,</span>
                <span class="s1">&#39;source_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span><span class="p">,</span>
                <span class="s1">&#39;source_p0&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span><span class="p">,</span>
                <span class="s1">&#39;use_w_source_correction_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_w_source_correction_p</span><span class="p">,</span>
                <span class="s1">&#39;use_w_source_correction_u&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_w_source_correction_u</span><span class="p">,</span>

                <span class="s1">&#39;source_sxx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxx</span><span class="p">,</span>
                <span class="s1">&#39;source_syy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syy</span><span class="p">,</span>
                <span class="s1">&#39;source_szz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_szz</span><span class="p">,</span>
                <span class="s1">&#39;source_sxy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxy</span><span class="p">,</span>
                <span class="s1">&#39;source_sxz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxz</span><span class="p">,</span>
                <span class="s1">&#39;source_syz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syz</span><span class="p">,</span>
            <span class="p">})</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.create_pml_indices"><a class="viewcode-back" href="../../ksimulation.html#kwave.kWaveSimulation.kWaveSimulation.create_pml_indices">[docs]</a>    <span class="k">def</span> <span class="nf">create_pml_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kgrid_dim</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">pml_inside</span><span class="p">,</span> <span class="n">is_axisymmetric</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Define index variables to remove the PML from the display if the optional</span>
<span class="sd">            input &#39;PlotPML&#39; is set to false</span>

<span class="sd">        Args:</span>
<span class="sd">            kgrid_dim: kWaveGrid dimensinality</span>
<span class="sd">            kgrid_N: kWaveGrid size in each direction</span>
<span class="sd">            pml_size: Size of the PML</span>
<span class="sd">            pml_inside: Whether the PML is inside the grid defined by the user</span>
<span class="sd">            is_axisymmetric: Whether the simulation is axisymmetric</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># comment by Farid: PlotPML is always False in Python version,</span>
        <span class="c1">#                       therefore if statement removed</span>
        <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span>
        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span>
        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">z</span>

        <span class="c1"># define index variables to allow original grid size to be maintained for</span>
        <span class="c1"># the _final and _all output variables if &#39;PMLInside&#39; is set to false</span>
        <span class="c1"># if self.record is None:</span>
        <span class="c1">#     self.record = Recorder()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">set_index_variables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">pml_inside</span><span class="p">,</span> <span class="n">is_axisymmetric</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Walter Simson, Farid Yagubbayli.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>