<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>kwave.kWaveSimulation - k-wave-python documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-toolbox-code.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">k-wave-python  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">k-wave-python  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/contrib.html">Contribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../development/development_environment.html">Development Environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">kwave</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.data.html">kwave.data module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.enums.html">kwave.enums module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.executor.html">kwave.executor module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kWaveSimulation.html">kwave.kWaveSimulation module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kgrid.html">kwave.kgrid module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kmedium.html">kwave.kmedium module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.ksensor.html">kwave.ksensor module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.ksource.html">kwave.ksource module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kspaceFirstOrder.html">kwave.kspaceFirstOrder module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kspaceFirstOrder2D.html">kwave.kspaceFirstOrder2D module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kspaceFirstOrder3D.html">kwave.kspaceFirstOrder3D module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.kspaceFirstOrderAS.html">kwave.kspaceFirstOrderAS module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.ktransducer.html">kwave.ktransducer module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.options.html">kwave.options module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kwave.recorder.html">kwave.recorder module</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../kwave.utils.html">kwave.utils package</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.checks.html">kwave.utils.checks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.colormap.html">kwave.utils.colormap module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.conversion.html">kwave.utils.conversion module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.data.html">kwave.utils.data module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.dotdictionary.html">kwave.utils.dotdictionary module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.filters.html">kwave.utils.filters module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.interp.html">kwave.utils.interp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.io.html">kwave.utils.io module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.mapgen.html">kwave.utils.mapgen module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.math.html">kwave.utils.math module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.matrix.html">kwave.utils.matrix module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.pml.html">kwave.utils.pml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.signals.html">kwave.utils.signals module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.utils.tictoc.html">kwave.utils.tictoc module</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.html">kwave.kWaveSimulation_helper package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.create_absorption_variables.html">kwave.kWaveSimulation_helper.create_absorption_variables module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.create_storage_variables.html">kwave.kWaveSimulation_helper.create_storage_variables module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.data_cast.html">kwave.kWaveSimulation_helper.data_cast module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.display_simulation_params.html">kwave.kWaveSimulation_helper.display_simulation_params module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.expand_grid_matrices.html">kwave.kWaveSimulation_helper.expand_grid_matrices module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.retract_transducer_grid_size.html">kwave.kWaveSimulation_helper.retract_transducer_grid_size module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.save_to_disk_func.html">kwave.kWaveSimulation_helper.save_to_disk_func module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.scale_source_terms_func.html">kwave.kWaveSimulation_helper.scale_source_terms_func module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.kWaveSimulation_helper.set_sound_speed_ref.html">kwave.kWaveSimulation_helper.set_sound_speed_ref module</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../kwave.reconstruction.html">kwave.reconstruction package</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.reconstruction.beamform.html">kwave.reconstruction.beamform module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.reconstruction.converter.html">kwave.reconstruction.converter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.reconstruction.shifted_transform.html">kwave.reconstruction.shifted_transform module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kwave.reconstruction.tools.html">kwave.reconstruction.tools module</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for kwave.kWaveSimulation</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">kwave.data</span> <span class="kn">import</span> <span class="n">Array</span>
<span class="kn">from</span> <span class="nn">kwave.kWaveSimulation_helper</span> <span class="kn">import</span> <span class="n">display_simulation_params</span><span class="p">,</span> <span class="n">set_sound_speed_ref</span><span class="p">,</span> <span class="n">expand_grid_matrices</span><span class="p">,</span> \
    <span class="n">create_storage_variables</span><span class="p">,</span> <span class="n">create_absorption_variables</span><span class="p">,</span> <span class="n">scale_source_terms_func</span>
<span class="kn">from</span> <span class="nn">kwave.kgrid</span> <span class="kn">import</span> <span class="n">kWaveGrid</span>
<span class="kn">from</span> <span class="nn">kwave.kmedium</span> <span class="kn">import</span> <span class="n">kWaveMedium</span>
<span class="kn">from</span> <span class="nn">kwave.ksensor</span> <span class="kn">import</span> <span class="n">kSensor</span>
<span class="kn">from</span> <span class="nn">kwave.ksource</span> <span class="kn">import</span> <span class="n">kSource</span>
<span class="kn">from</span> <span class="nn">kwave.ktransducer</span> <span class="kn">import</span> <span class="n">NotATransducer</span>
<span class="kn">from</span> <span class="nn">kwave.options</span> <span class="kn">import</span> <span class="n">SimulationOptions</span>
<span class="kn">from</span> <span class="nn">kwave.recorder</span> <span class="kn">import</span> <span class="n">Recorder</span>
<span class="kn">from</span> <span class="nn">kwave.utils.checks</span> <span class="kn">import</span> <span class="n">check_stability</span>
<span class="kn">from</span> <span class="nn">kwave.utils.colormap</span> <span class="kn">import</span> <span class="n">get_color_map</span>
<span class="kn">from</span> <span class="nn">kwave.utils.conversion</span> <span class="kn">import</span> <span class="n">cast_to_type</span><span class="p">,</span> <span class="n">cart2grid</span>
<span class="kn">from</span> <span class="nn">kwave.utils.data</span> <span class="kn">import</span> <span class="n">get_smallest_possible_type</span><span class="p">,</span> <span class="n">get_date_string</span>
<span class="kn">from</span> <span class="nn">kwave.utils.dotdictionary</span> <span class="kn">import</span> <span class="n">dotdict</span>
<span class="kn">from</span> <span class="nn">kwave.utils.filters</span> <span class="kn">import</span> <span class="n">smooth</span>
<span class="kn">from</span> <span class="nn">kwave.utils.matlab</span> <span class="kn">import</span> <span class="n">matlab_find</span><span class="p">,</span> <span class="n">matlab_mask</span>
<span class="kn">from</span> <span class="nn">kwave.utils.matrix</span> <span class="kn">import</span> <span class="n">num_dim2</span>


<div class="viewcode-block" id="kWaveSimulation"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">kWaveSimulation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="kWaveSimulation.__init__"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">kgrid</span><span class="p">:</span> <span class="n">kWaveGrid</span><span class="p">,</span>
                 <span class="n">medium</span><span class="p">:</span> <span class="n">kWaveMedium</span><span class="p">,</span>
                 <span class="n">source</span><span class="p">,</span>
                 <span class="n">sensor</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span> <span class="o">=</span> <span class="n">kgrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">medium</span> <span class="o">=</span> <span class="n">medium</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="o">=</span> <span class="n">sensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># =========================================================================</span>
        <span class="c1"># FLAGS WHICH DEPEND ON USER INPUTS (THESE SHOULD NOT BE MODIFIED)</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># flags which control the type of simulation</span>
        <span class="c1">#: Whether simulation type is axisymmetric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userarg_axisymmetric</span>      <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axisymmetric&#39;</span><span class="p">]</span>

        <span class="c1"># flags which control the characteristics of the sensor</span>
        <span class="c1">#: Whether time reversal simulation is enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userarg_time_rev</span>          <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_rev&#39;</span><span class="p">]</span>

        <span class="c1">#: Whether sensor.mask should be re-ordered.</span>
        <span class="c1">#: True if sensor.mask is Cartesian with nearest neighbour interpolation which is calculated using a binary mask</span>
        <span class="c1">#: and thus must be re-ordered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_data</span>              <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#: Whether the sensor.mask is binary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span>        <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">#: If the sensor.mask is a list of cuboid corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userarg_cuboid_corners</span>    <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cuboid_corners&#39;</span><span class="p">]</span>

        <span class="c1">#: If tse sensor is an object of the kWaveTransducer class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_sensor</span>         <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">record</span> <span class="o">=</span> <span class="n">Recorder</span><span class="p">()</span>

        <span class="c1"># transducer source flags</span>
        <span class="c1">#: transducer is object of kWaveTransducer class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span>         <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#: Apply receive elevation focus on the transducer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># general</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">COLOR_MAP</span>                       <span class="o">=</span> <span class="n">get_color_map</span><span class="p">()</span>      <span class="c1">#: default color map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATE_SIM_TIME_STEPS</span>         <span class="o">=</span> <span class="mi">50</span>                   <span class="c1">#: time steps used to estimate simulation time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HIGHEST_PRIME_FACTOR_WARNING</span>    <span class="o">=</span> <span class="mi">7</span>                    <span class="c1">#: largest prime factor before warning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KSPACE_CFL</span>                      <span class="o">=</span> <span class="mf">0.3</span>                  <span class="c1">#: default CFL value used if kgrid.t_array is set to &#39;auto&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PSTD_CFL</span>                        <span class="o">=</span> <span class="mf">0.1</span>                  <span class="c1">#: default CFL value used if kgrid.t_array is set to &#39;auto&#39;</span>

        <span class="c1"># source types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_S_MODE_DEF</span>               <span class="o">=</span> <span class="s1">&#39;additive&#39;</span>           <span class="c1">#: source mode for stress sources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_P_MODE_DEF</span>               <span class="o">=</span> <span class="s1">&#39;additive&#39;</span>           <span class="c1">#: source mode for pressure sources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_U_MODE_DEF</span>               <span class="o">=</span> <span class="s1">&#39;additive&#39;</span>           <span class="c1">#: source mode for velocity sources</span>

        <span class="c1"># filenames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">STREAM_TO_DISK_FILENAME</span>         <span class="o">=</span> <span class="s1">&#39;temp_sensor_data.bin&#39;</span>   <span class="c1">#: default disk stream filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LOG_NAME</span>                        <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;k-Wave-Log-&#39;</span><span class="p">,</span> <span class="n">get_date_string</span><span class="p">()]</span>  <span class="c1">#: default log filename</span>

        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axisymmetric&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cuboid_corners&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_rev&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  start time: </span><span class="si">{</span><span class="n">get_date_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_compression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_shear</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#: Indexing variable corresponding to the location of all the pressure source elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#: Indexing variable corresponding to the location of all the velocity source elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#: Indexing variable corresponding to the location of all the stress source elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#: Delay mask that accounts for the beamforming delays and elevation focussing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_mask</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla1</span>  <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: absorbing fractional Laplacian operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_tau</span>     <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: absorbing fractional Laplacian coefficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla2</span>  <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: dispersive fractional Laplacian operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absorb_eta</span>     <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: dispersive fractional Laplacian coefficient</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>             <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: Alias to kgrid.dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span>           <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: Alias to medium.density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c0</span>             <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#: Alias to medium.sound_speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">equation_of_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Set equation of state variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">absorbing</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">stokes</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;stokes&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;absorbing&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;loseless&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            False if no output of any kind is required</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blank_sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">            True if sensor.mask is not defined but _max_all or _final variables are still recorded</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p_max&#39;</span><span class="p">,</span> <span class="s1">&#39;p_min&#39;</span><span class="p">,</span> <span class="s1">&#39;p_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;u_non_staggered&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;u_split_field&#39;</span><span class="p">,</span> <span class="s1">&#39;u_max&#39;</span><span class="p">,</span> <span class="s1">&#39;u_min&#39;</span><span class="p">,</span> <span class="s1">&#39;u_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;I_avg&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="n">fields</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elastic_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if elastic simulation False if fluid simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;pstdElastic&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic&#39;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kspace_elastic_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if elastic simulation with k-space correction False if ordinary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;kspaceElastic&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axisymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if fluid axisymmetric simulation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;kspaceFirstOrderAS&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">userarg_axisymmetric</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kelvin_voigt_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether the simulation is elastic with absorption</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nonuniform_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if the computational grid is non-uniform</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">nonuniform</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_rev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True for time reversal simulaions using sensor.time_reversal_boundary_data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">time_reversal_boundary_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">userarg_time_rev</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elastic_time_rev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if using time reversal with the elastic code</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">compute_directivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if directivity calculations in 2D are used by setting sensor.directivity_angle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># check for sensor directivity input and set flag</span>
                <span class="n">directivity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">directivity</span>
                <span class="k">if</span> <span class="n">directivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">directivity</span><span class="o">.</span><span class="n">angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cuboid_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether the sensor.mask is a list of cuboid corners</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">userarg_cuboid_corners</span>

    <span class="c1">##############</span>
    <span class="c1"># flags which control the types of source used</span>
    <span class="c1">##############</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># initial pressure</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether initial pressure source is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set flag</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p0_elastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># initial pressure in the elastic code</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether initial pressure source is present in the elastic code (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Not clear where this flag is set</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying pressure source is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flag to the length of the source, this allows source.p</span>
            <span class="c1"># to be shorter than kgrid.Nt</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_p_labelled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># time-varying pressure with labelled source mask</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            True/False if labelled/binary source mask, respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the mask is binary or labelled</span>
            <span class="n">p_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">p_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_ux</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying particle velocity source is used in X-direction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flgs to the length of the sources, this allows the</span>
            <span class="c1"># inputs to be defined independently and be of any length</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">ux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_uy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying particle velocity source is used in Y-direction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flgs to the length of the sources, this allows the</span>
            <span class="c1"># inputs to be defined independently and be of any length</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_uz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying particle velocity source is used in Z-direction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set source flgs to the length of the sources, this allows the</span>
            <span class="c1"># inputs to be defined independently and be of any length</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">uz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_u_labelled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying velocity source with labelled source mask is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the mask is binary or labelled</span>
            <span class="n">u_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># binary source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># labelled source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_sxx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source in X-&gt;X direction is present (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_syy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source in Y-&gt;Y direction is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_szz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source in Z-&gt;Z direction is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">szz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">szz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_sxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source in X-&gt;Y direction is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_sxz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source in X-&gt;Z direction is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">sxz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_syz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source in Y-&gt;Z direction is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">syz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_s_labelled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether time-varying stress source with labelled source mask is present (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">s_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check if the mask is binary or labelled</span>
            <span class="n">s_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">s_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">s_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># binary source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># labelled source mask</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_w_source_correction_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether to use the w source correction instead of the k-space source correction for pressure sources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_frequency_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_w_source_correction_u</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Whether to use the w source correction instead of the k-space source correction for velocity sources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">,</span> <span class="s1">&#39;uy&#39;</span><span class="p">,</span> <span class="s1">&#39;uz&#39;</span><span class="p">,</span> <span class="s1">&#39;u_mask&#39;</span><span class="p">]]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_frequency_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">flag</span>

<div class="viewcode-block" id="kWaveSimulation.input_checking"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.input_checking">[docs]</a>    <span class="k">def</span> <span class="nf">input_checking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calling_func_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the input fields for correctness and validness</span>

<span class="sd">        Args:</span>
<span class="sd">            calling_func_name: Name of the script that calls this function</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calling_func_name</span> <span class="o">=</span> <span class="n">calling_func_name</span>

        <span class="n">k_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">k_Nx</span><span class="p">,</span> <span class="n">k_Ny</span><span class="p">,</span> <span class="n">k_Nz</span><span class="p">,</span> <span class="n">k_Nt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_calling_func_name_and_dim</span><span class="p">(</span><span class="n">calling_func_name</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">)</span>

        <span class="c1"># run subscript to check optional inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">SimulationOptions</span><span class="o">.</span><span class="n">option_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span>

        <span class="c1"># TODO(Walter): clean this up with getters in simulation options pml size</span>
        <span class="n">pml_x_size</span><span class="p">,</span> <span class="n">pml_y_size</span><span class="p">,</span> <span class="n">pml_z_size</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_x_size</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_y_size</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_z_size</span>
        <span class="n">pml_size</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">pml_x_size</span><span class="p">,</span> <span class="n">pml_y_size</span><span class="p">,</span> <span class="n">pml_z_size</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_start_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_index_data_type</span><span class="p">()</span>

        <span class="n">user_medium_density_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_medium</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">)</span>

        <span class="c1"># select the reference sound speed used in the k-space operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_compression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_ref_shear</span> \
            <span class="o">=</span> <span class="n">set_sound_speed_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kspace_elastic_code</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_source</span><span class="p">(</span><span class="n">k_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_sensor</span><span class="p">(</span><span class="n">k_dim</span><span class="p">,</span> <span class="n">k_Nt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_kgrid_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_precision</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_input_combinations</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="n">user_medium_density_input</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># run subscript to display time step, max supported frequency etc.</span>
        <span class="n">display_simulation_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smooth_and_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_sensor_variables</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_absorption_vars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_pseudonyms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_source_terms</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">scale_source_terms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_pml_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_calling_func_name_and_dim"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_calling_func_name_and_dim">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_calling_func_name_and_dim</span><span class="p">(</span><span class="n">calling_func_name</span><span class="p">,</span> <span class="n">kgrid_dim</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check correct function has been called for the dimensionality of kgrid</span>

<span class="sd">        Args:</span>
<span class="sd">            calling_func_name: Name of the script that makes calls to kWaveSimulation</span>
<span class="sd">            kgrid_dim: Dimensionality of the kWaveGrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">calling_func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;pstdElastic&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic&#39;</span><span class="p">)),</span> \
            <span class="s2">&quot;Elastic simulation is not supported.&quot;</span>

        <span class="k">if</span> <span class="n">calling_func_name</span> <span class="o">==</span> <span class="s1">&#39;kspaceFirstOrder1D&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kgrid has the wrong dimensionality for </span><span class="si">{</span><span class="n">calling_func_name</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="k">elif</span> <span class="n">calling_func_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kspaceFirstOrder2D&#39;</span><span class="p">,</span> <span class="s1">&#39;pstdElastic2D&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic2D&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceFirstOrderAS&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kgrid has the wrong dimensionality for </span><span class="si">{</span><span class="n">calling_func_name</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="k">elif</span> <span class="n">calling_func_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kspaceFirstOrder3D&#39;</span><span class="p">,</span> <span class="s1">&#39;pstdElastic3D&#39;</span><span class="p">,</span> <span class="s1">&#39;kspaceElastic3D&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;kgrid has the wrong dimensionality for </span><span class="si">{</span><span class="n">calling_func_name</span><span class="si">}</span><span class="s1">.&#39;</span></div>

<div class="viewcode-block" id="kWaveSimulation.print_start_status"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.print_start_status">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">print_start_status</span><span class="p">(</span><span class="n">is_elastic_code</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update command-line status with the start time</span>

<span class="sd">        Args:</span>
<span class="sd">            is_elastic_code: is the simulation elastic</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_elastic_code</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running k-Wave elastic simulation...&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running k-Wave simulation...&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  start time: </span><span class="si">{</span><span class="n">get_date_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.set_index_data_type"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.set_index_data_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_index_data_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-calculate the data type needed to store the matrix indices given the</span>
<span class="sd">        total number of grid points: indexing variables will be created using this data type to save memory</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_grid_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">total_grid_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span> <span class="o">=</span> <span class="n">get_smallest_possible_type</span><span class="p">(</span><span class="n">total_grid_points</span><span class="p">,</span> <span class="s1">&#39;uint&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_medium"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_medium">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_medium</span><span class="p">(</span><span class="n">medium</span><span class="p">,</span> <span class="n">kgrid_k</span><span class="p">,</span> <span class="n">is_elastic</span><span class="p">,</span> <span class="n">is_axisymmetric</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the properties of the medium structure for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            medium: kWaveMedium instance</span>
<span class="sd">            kgrid_k: kWaveGrid.k matrix</span>
<span class="sd">            is_elastic: Whether the simulation is elastic</span>
<span class="sd">            is_axisymmetric: Whether the simulation is axisymmetric</span>

<span class="sd">        Returns:</span>
<span class="sd">            Medium Density</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if using the fluid code, allow the density field to be blank if the medium is homogeneous</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_elastic</span> <span class="ow">and</span> <span class="n">medium</span><span class="o">.</span><span class="n">density</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">user_medium_density_input</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">medium</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">medium</span><span class="o">.</span><span class="n">ensure_defined</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
            <span class="n">user_medium_density_input</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># check medium absorption inputs for the fluid code</span>
        <span class="n">is_absorbing</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">medium</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s1">&#39;alpha_coeff&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha_power&#39;</span><span class="p">))</span>
        <span class="n">is_stokes</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_axisymmetric</span> <span class="ow">or</span> <span class="n">medium</span><span class="o">.</span><span class="n">alpha_mode</span> <span class="o">==</span> <span class="s1">&#39;stokes&#39;</span><span class="p">)</span>
        <span class="n">medium</span><span class="o">.</span><span class="n">set_absorbing</span><span class="p">(</span><span class="n">is_absorbing</span><span class="p">,</span> <span class="n">is_stokes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_absorbing</span><span class="p">:</span>
            <span class="n">medium</span><span class="o">.</span><span class="n">check_fields</span><span class="p">(</span><span class="n">kgrid_k</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">user_medium_density_input</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_source"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_source">[docs]</a>    <span class="k">def</span> <span class="nf">check_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kgrid_dim</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the source properties for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            kgrid_dim: kWaveGrid dimension</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># CHECK SENSOR STRUCTURE INPUTS</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># check sensor fields</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># check the sensor input is valid</span>
            <span class="c1"># TODO FARID move this check as a type checking</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="p">(</span><span class="n">kSensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)),</span> \
                <span class="s1">&#39;sensor must be defined as an object of the kSensor or kWaveTransducer class.&#39;</span>

            <span class="c1"># check if sensor is a transducer, otherwise check input fields</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

                    <span class="c1"># check field names, including the directivity inputs for the</span>
                    <span class="c1"># regular 2D code, but not the axisymmetric code</span>
                    <span class="c1"># TODO question to Walter: we do not need following checks anymore because we have kSensor that defines the structure, right?</span>
                    <span class="c1"># if self.axisymmetric:</span>
                    <span class="c1">#     check_field_names(self.sensor, *[&#39;mask&#39;, &#39;time_reversal_boundary_data&#39;, &#39;frequency_response&#39;,</span>
                    <span class="c1">#                                        &#39;record_mode&#39;, &#39;record&#39;, &#39;record_start_index&#39;])</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     check_field_names(self.sensor, *[&#39;mask&#39;, &#39;directivity&#39;, &#39;time_reversal_boundary_data&#39;,</span>
                    <span class="c1">#                                      &#39;frequency_response&#39;, &#39;record_mode&#39;, &#39;record&#39;, &#39;record_start_index&#39;])</span>

                    <span class="c1"># check for sensor directivity input and set flag</span>
                    <span class="n">directivity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">directivity</span>
                    <span class="k">if</span> <span class="n">directivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">directivity</span><span class="o">.</span><span class="n">angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                        <span class="c1"># make sure the sensor mask is not blank</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;The mask must be defined for the sensor&#39;</span>

                        <span class="c1"># check sensor.directivity.pattern and sensor.mask have the same size</span>
                        <span class="k">assert</span> <span class="n">directivity</span><span class="o">.</span><span class="n">angle</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> \
                            <span class="s1">&#39;sensor.directivity.angle and sensor.mask must be the same size.&#39;</span>

                        <span class="c1"># check if directivity size input exists, otherwise make it</span>
                        <span class="c1"># a constant times kgrid.dx</span>
                        <span class="k">if</span> <span class="n">directivity</span><span class="o">.</span><span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">directivity</span><span class="o">.</span><span class="n">set_default_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>

                        <span class="c1"># find the unique directivity angles</span>
                        <span class="c1"># assign the wavenumber vectors</span>
                        <span class="n">directivity</span><span class="o">.</span><span class="n">set_unique_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
                        <span class="n">directivity</span><span class="o">.</span><span class="n">set_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># TODO question to Walter: we do not need following checks anymore because we have kSensor that defines the structure, right?</span>
                    <span class="c1"># check field names without directivity inputs (these are not supported in 1 or 3D)</span>
                    <span class="c1"># check_field_names(self.sensor, *[&#39;mask&#39;, &#39;time_reversal_boundary_data&#39;, &#39;frequency_response&#39;,</span>
                    <span class="c1">#                                    &#39;record_mode&#39;, &#39;record&#39;, &#39;record_start_index&#39;])</span>
                    <span class="k">pass</span>

                <span class="c1"># check for time reversal inputs and set flgs</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">time_reversal_boundary_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># check for sensor.record and set usage flgs - if no flgs are</span>
                <span class="c1"># given, the time history of the acoustic pressure is recorded by</span>
                <span class="c1"># default</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="c1"># check for time reversal data</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: sensor.record is not used for time reversal reconstructions&#39;</span><span class="p">)</span>

                    <span class="c1"># check the input is a cell array</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s1">&#39;sensor.record must be given as a list, e.g. [&quot;p&quot;, &quot;u&quot;]&#39;</span>

                    <span class="c1"># check the sensor record flgs</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">set_flags_from_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">)</span>

                <span class="c1"># enforce the sensor.mask field unless just recording the max_all</span>
                <span class="c1"># and _final variables</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p_max&#39;</span><span class="p">,</span> <span class="s1">&#39;p_min&#39;</span><span class="p">,</span> <span class="s1">&#39;p_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;u_non_staggered&#39;</span><span class="p">,</span> <span class="s1">&#39;u_split_field&#39;</span><span class="p">,</span> <span class="s1">&#39;u_max&#39;</span><span class="p">,</span> <span class="s1">&#39;u_min&#39;</span><span class="p">,</span> <span class="s1">&#39;u_rms&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;I_avg&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="n">fields</span><span class="p">)):</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="c1"># check if sensor mask is a binary grid, a set of cuboid corners,</span>
                <span class="c1"># or a set of Cartesian interpolation points</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">kgrid_dim</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>

                        <span class="c1"># check the grid is binary</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span> \
                            <span class="s1">&#39;sensor.mask must be a binary grid (numeric values must be 0 or 1).&#39;</span>

                        <span class="c1"># check the grid is not empty</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;sensor.mask must be a binary grid with at least one element set to 1.&#39;</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">kgrid_dim</span><span class="p">:</span>

                        <span class="c1"># make sure the points are integers</span>
                        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;sensor.mask cuboid corner indices must be integers.&#39;</span>

                        <span class="c1"># store a copy of the cuboid corners</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span>

                        <span class="c1"># check the list makes sense</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be defined as [x1, x2; ...].&#39;&#39; where x2 =&gt; x1, etc.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be defined as [x1, y1, x2, y2; ...].&#39;&#39; where x2 =&gt; x1, etc.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be defined as [x1, y1, z1, x2, y2, z2; ...].&#39;&#39; where x2 =&gt; x1, etc.&#39;</span><span class="p">)</span>

                        <span class="c1"># check the list are within bounds</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">)</span> <span class="ow">or</span> \
                                        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">)</span> <span class="ow">or</span> \
                                        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nz</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.mask cuboid corners must be within the grid.&#39;</span><span class="p">)</span>

                        <span class="c1"># create a binary mask for display from the list of corners</span>
                        <span class="c1"># TODO FARID mask should be option_factory in sensor not here</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cuboid_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># check the Cartesian sensor mask is the correct size</span>
                        <span class="c1"># (1 x N, 2 x N, 3 x N)</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">kgrid_dim</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> \
                            <span class="sa">f</span><span class="s1">&#39;Cartesian sensor.mask for a </span><span class="si">{</span><span class="n">kgrid_dim</span><span class="si">}</span><span class="s1">D simulation must be given as a </span><span class="si">{</span><span class="n">kgrid_dim</span><span class="si">}</span><span class="s1"> by N array.&#39;</span>

                        <span class="c1"># set Cartesian mask flag (this is modified in</span>
                        <span class="c1"># createStorageVariables if the interpolation setting is</span>
                        <span class="c1"># set to nearest)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span> <span class="o">=</span> <span class="kc">False</span>

                        <span class="c1"># extract Cartesian data from sensor mask</span>
                        <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># align sensor data as a column vector to be the</span>
                            <span class="c1"># same as kgrid.x_vec so that calls to interp1</span>
                            <span class="c1"># return data in the correct dimension</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

                            <span class="c1"># add sensor_x to the record structure for use with</span>
                            <span class="c1"># the _extractSensorData subfunction</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span>
                            <span class="s2">&quot;record.sensor_x = sensor_x;&quot;</span>

                        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

                        <span class="c1"># compute an equivalent sensor mask using nearest neighbour</span>
                        <span class="c1"># interpolation, if flgs.time_rev = false and</span>
                        <span class="c1"># cartesian_interp = &#39;linear&#39; then this is only used for</span>
                        <span class="c1"># display, if flgs.time_rev = true or cartesian_interp =</span>
                        <span class="c1"># &#39;nearest&#39; this grid is used as the sensor.mask</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_index</span> <span class="o">=</span> <span class="n">cart2grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">)</span>

                        <span class="c1"># if in time reversal mode, reorder the p0 input data in</span>
                        <span class="c1"># the order of the binary sensor_mask</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
<span class="w">                            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            # append the reordering data</span>
<span class="sd">                            new_col_pos = length(sensor.time_reversal_boundary_data(1, :)) + 1;</span>
<span class="sd">                            sensor.time_reversal_boundary_data(:, new_col_pos) = order_index;</span>
<span class="sd">        </span>
<span class="sd">                            # reorder p0 based on the order_index</span>
<span class="sd">                            sensor.time_reversal_boundary_data = sort_rows(sensor.time_reversal_boundary_data, new_col_pos);</span>
<span class="sd">        </span>
<span class="sd">                            # remove the reordering data</span>
<span class="sd">                            sensor.time_reversal_boundary_data = sensor.time_reversal_boundary_data(:, 1:new_col_pos - 1);</span>
<span class="sd">                            &quot;&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set transducer sensor flag</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_sensor</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># check to see if there is an elevation focus</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">elevation_focus_distance</span><span class="p">):</span>
                    <span class="c1"># set flag</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># get the elevation mask that is used to extract the correct values</span>
                    <span class="c1"># from the sensor data buffer for averaging</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">elevation_beamforming_mask</span>

        <span class="c1"># check for directivity inputs with time reversal</span>
        <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_directivity</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: sensor directivity fields are not used for time reversal.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_sensor"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_sensor">[docs]</a>    <span class="k">def</span> <span class="nf">check_sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">k_Nt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the Sensor properties for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            k_dim: kWaveGrid dimensionality</span>
<span class="sd">            k_Nt: Number of time steps in kWaveGrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># CHECK SOURCE STRUCTURE INPUTS</span>
        <span class="c1"># =========================================================================</span>

        <span class="c1"># check source inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="p">(</span><span class="n">kSource</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">)):</span>
            <span class="c1"># allow an invalid or empty source input if computing time reversal,</span>
            <span class="c1"># otherwise return error</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">,</span> <span class="s1">&#39;source must be defined as an object of the kSource or kWaveTransducer classes.&#39;</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">NotATransducer</span><span class="p">):</span>

            <span class="c1"># --------------------------</span>
            <span class="c1"># SOURCE IS NOT A TRANSDUCER</span>
            <span class="c1"># --------------------------</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                check allowable source types</span>
<span class="sd">                </span>
<span class="sd">                Depending on the kgrid dimensionality and the simulation type, </span>
<span class="sd">                    following fields are allowed &amp; might be use:</span>
<span class="sd">                </span>
<span class="sd">                kgrid.dim == 1:</span>
<span class="sd">                    non-elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;p&#39;, &#39;p_mask&#39;, &#39;p_mode&#39;, &#39;p_frequency_ref&#39;, &#39;ux&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;, &#39;u_frequency_ref&#39;]</span>
<span class="sd">                kgrid.dim == 2:</span>
<span class="sd">                    non-elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;p&#39;, &#39;p_mask&#39;, &#39;p_mode&#39;, &#39;p_frequency_ref&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;, &#39;u_frequency_ref&#39;]</span>
<span class="sd">                    elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;sxx&#39;, &#39;syy&#39;, &#39;sxy&#39;, &#39;s_mask&#39;, &#39;s_mode&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;]</span>
<span class="sd">                kgrid.dim == 3:</span>
<span class="sd">                    non-elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;p&#39;, &#39;p_mask&#39;, &#39;p_mode&#39;, &#39;p_frequency_ref&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;uz&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;, &#39;u_frequency_ref&#39;]</span>
<span class="sd">                    elastic code:</span>
<span class="sd">                        [&#39;p0&#39;, &#39;sxx&#39;, &#39;syy&#39;, &#39;szz&#39;, &#39;sxy&#39;, &#39;sxz&#39;, &#39;syz&#39;, &#39;s_mask&#39;, &#39;s_mode&#39;, &#39;ux&#39;, &#39;uy&#39;, &#39;uz&#39;, &#39;u_mask&#39;, &#39;u_mode&#39;]</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">)</span>

            <span class="c1"># check for a time varying pressure source input</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># check the source mode input is valid</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_P_MODE_DEF</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span> <span class="o">&gt;</span> <span class="n">k_Nt</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;  WARNING: source.p has more time points than kgrid.Nt, remaining time points will not be used.&#39;</span><span class="p">)</span>

                <span class="c1"># create an indexing variable corresponding to the location of all the source elements</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">)</span>

                <span class="c1"># check if the mask is binary or labelled</span>
                <span class="n">p_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">)</span>

                <span class="c1"># create a second indexing variable</span>
                <span class="k">if</span> <span class="n">p_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">p_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># set signal index to all elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set signal index to the labels (this allows one input signal</span>
                    <span class="c1"># to be used for each source label)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># convert the data type depending on the number of indices</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p_labelled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_source_sig_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="c1"># check for time varying velocity source input and set source flag</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">,</span> <span class="s1">&#39;uy&#39;</span><span class="p">,</span> <span class="s1">&#39;uz&#39;</span><span class="p">,</span> <span class="s1">&#39;u_mask&#39;</span><span class="p">]]):</span>

                <span class="c1"># check the source mode input is valid</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_U_MODE_DEF</span>

                <span class="c1"># create an indexing variable corresponding to the location of all</span>
                <span class="c1"># the source elements</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">)</span>

                <span class="c1"># check if the mask is binary or labelled</span>
                <span class="n">u_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">)</span>

                <span class="c1"># create a second indexing variable</span>
                <span class="k">if</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">u_unique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="c1"># set signal index to all elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set signal index to the labels (this allows one input signal</span>
                    <span class="c1"># to be used for each source label)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">u_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># convert the data type depending on the number of indices</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_u_labelled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_source_sig_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="c1"># check for time varying stress source input and set source flag</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sxx&#39;</span><span class="p">,</span> <span class="s1">&#39;syy&#39;</span><span class="p">,</span> <span class="s1">&#39;szz&#39;</span><span class="p">,</span> <span class="s1">&#39;sxy&#39;</span><span class="p">,</span> <span class="s1">&#39;sxz&#39;</span><span class="p">,</span> <span class="s1">&#39;syz&#39;</span><span class="p">,</span> <span class="s1">&#39;s_mask&#39;</span><span class="p">]]):</span>
                <span class="c1"># create an indexing variable corresponding to the location of all</span>
                <span class="c1"># the source elements</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="s1">&#39;s_source_pos_index = find(source.s_mask != 0);&#39;</span>

                <span class="c1"># check if the mask is binary or labelled</span>
                <span class="s1">&#39;s_unique = unique(source.s_mask);&#39;</span>

                <span class="c1"># create a second indexing variable</span>
                <span class="k">if</span> <span class="n">eng</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;numel(s_unique) &lt;= 2 &amp;&amp; sum(s_unique) == 1&#39;</span><span class="p">):</span>
                    <span class="c1"># set signal index to all elements</span>
                    <span class="n">eng</span><span class="o">.</span><span class="n">workspace</span><span class="p">[</span><span class="s1">&#39;s_source_sig_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># set signal index to the labels (this allows one input signal</span>
                    <span class="c1"># to be used for each source label)</span>
                    <span class="n">s_source_sig_index</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">s_mask</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">s_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

                <span class="sa">f</span><span class="s1">&#39;s_source_pos_index = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="si">}</span><span class="s1">(s_source_pos_index);&#39;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_s_labelled</span><span class="p">:</span>
                    <span class="sa">f</span><span class="s1">&#39;s_source_sig_index = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="si">}</span><span class="s1">(s_source_sig_index);&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ----------------------</span>
            <span class="c1"># SOURCE IS A TRANSDUCER</span>
            <span class="c1"># ----------------------</span>

            <span class="c1"># if the sensor is a transducer, check that the simulation is in 3D</span>
            <span class="k">assert</span> <span class="n">k_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Transducer inputs are only compatible with 3D simulations.&#39;</span>

            <span class="c1"># get the input signal - this is appended with zeros if required to</span>
            <span class="c1"># account for the beamforming delays (this will throw an error if the</span>
            <span class="c1"># input signal is not defined)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">input_signal</span>

            <span class="c1"># get the delay mask that accounts for the beamforming delays and</span>
            <span class="c1"># elevation focussing; this is used so that a single time series can be</span>
            <span class="c1"># applied to the complete transducer mask with different delays</span>
            <span class="n">delay_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">delay_mask</span><span class="p">()</span>

            <span class="c1"># set source flag - this should be the length of signal minus the</span>
            <span class="c1"># maximum delay</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">delay_mask</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># get the active elements mask</span>
            <span class="n">active_elements_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">active_elements_mask</span>

            <span class="c1"># get the apodization mask if not set to &#39;Rectangular&#39; and convert to a</span>
            <span class="c1"># linear array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">transmit_apodization</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">transmit_apodization_mask</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_transmit_apodization</span><span class="p">[</span><span class="n">active_elements_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># create indexing variable corresponding to the active elements</span>
            <span class="c1"># and convert the data type depending on the number of indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">active_elements_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="c1"># convert the delay mask to an indexing variable (this doesn&#39;t need to</span>
            <span class="c1"># be modified if the grid is expanded) which tells each point in the</span>
            <span class="c1"># source mask which point in the input_signal should be used</span>
            <span class="n">delay_mask</span> <span class="o">=</span> <span class="n">matlab_mask</span><span class="p">(</span><span class="n">delay_mask</span><span class="p">,</span> <span class="n">active_elements_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># compatibility</span>

            <span class="c1"># convert the data type depending on the maximum value of the delay</span>
            <span class="c1"># mask and the length of the source</span>
            <span class="n">smallest_type</span> <span class="o">=</span> <span class="n">get_smallest_possible_type</span><span class="p">(</span><span class="n">delay_mask</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="s1">&#39;uint&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">smallest_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">delay_mask</span> <span class="o">=</span> <span class="n">delay_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">smallest_type</span><span class="p">)</span>

            <span class="c1"># move forward by 1 as a delay of 0 corresponds to the first point in the input signal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delay_mask</span> <span class="o">=</span> <span class="n">delay_mask</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># clean up unused variables</span>
            <span class="k">del</span> <span class="n">active_elements_mask</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_kgrid_time"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_kgrid_time">[docs]</a>    <span class="k">def</span> <span class="nf">check_kgrid_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check time-related kWaveGrid inputs</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check kgrid for t_array existance, and create if not defined</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">t_array</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">t_array</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>

            <span class="c1"># check for time reversal mode</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kgrid.t_array (Nt and dt) must be defined explicitly in time reversal mode.&#39;</span><span class="p">)</span>

            <span class="c1"># check for time varying sources</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0_elastic</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_sxx</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_szz</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_sxy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxz</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syz</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kgrid.t_array (Nt and dt) must be defined explicitly when using a time-varying source.&#39;</span><span class="p">)</span>

            <span class="c1"># create the time array using the compressional sound speed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">makeTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">KSPACE_CFL</span><span class="p">)</span>

        <span class="c1"># check kgrid.t_array for stability given medium properties</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span><span class="p">:</span>

            <span class="c1"># calculate the largest timestep for which the model is stable</span>

            <span class="n">dt_stability_limit</span> <span class="o">=</span> <span class="n">check_stability</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">)</span>

            <span class="c1"># give a warning if the timestep is larger than stability limit allows</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="n">dt_stability_limit</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;  WARNING: time step may be too large for a stable simulation.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.select_precision"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.select_precision">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">select_precision</span><span class="p">(</span><span class="n">opt</span><span class="p">:</span> <span class="n">SimulationOptions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the minimal precision for storing the data</span>

<span class="sd">        Args:</span>
<span class="sd">            opt: SimulationOptions instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            Minimal precision for variable allocation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set storage variable type based on data_cast - this enables the</span>
        <span class="c1"># output variables to be directly created in the data_cast format,</span>
        <span class="c1"># rather than creating them in double precision and then casting them</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;off&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;gsingle&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;gdouble&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;gpuArray&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;gpuArray is not supported in Python-version&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;kWaveGPUsingle&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
        <span class="k">elif</span> <span class="n">opt</span><span class="o">.</span><span class="n">data_cast</span> <span class="o">==</span> <span class="s1">&#39;kWaveGPUdouble&#39;</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;Unknown &#39;&#39;DataCast&#39;&#39; option&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">precision</span></div>

<div class="viewcode-block" id="kWaveSimulation.check_input_combinations"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.check_input_combinations">[docs]</a>    <span class="k">def</span> <span class="nf">check_input_combinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="n">SimulationOptions</span><span class="p">,</span> <span class="n">user_medium_density_input</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the input combinations for correctness and validity</span>

<span class="sd">        Args:</span>
<span class="sd">            opt: SimulationOptions instance</span>
<span class="sd">            user_medium_density_input: Medium Density</span>
<span class="sd">            k_dim: kWaveGrid dimensionality</span>
<span class="sd">            pml_size: Size of the PML</span>
<span class="sd">            kgrid_N: kWaveGrid size in each direction</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># =========================================================================</span>
        <span class="c1"># CHECK FOR VALID INPUT COMBINATIONS</span>
        <span class="c1"># =========================================================================</span>

        <span class="c1"># enforce density input if velocity sources or output are being used</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">user_medium_density_input</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u_max</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u_rms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;medium.density must be explicitly defined if velocity inputs or outputs are used, even in homogeneous media.&#39;</span><span class="p">)</span>

        <span class="c1"># TODO(walter): move to check medium</span>
        <span class="c1"># enforce density input if nonlinear equations are being used</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">user_medium_density_input</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">is_nonlinear</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;medium.density must be explicitly defined if medium.BonA is specified.&#39;</span><span class="p">)</span>

        <span class="c1"># check sensor compatability options for flgs.compute_directivity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="n">k_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_directivity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span> <span class="ow">and</span> <span class="n">opt</span><span class="o">.</span><span class="n">cartesian_interp</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor directivity fields are only compatible with binary sensor masks or &#39;&#39;CartInterp&#39;&#39; set to &#39;&#39;nearest&#39;&#39;.&#39;</span><span class="p">)</span>

        <span class="c1"># check for split velocity output</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">u_split_field</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The option sensor.record = {&#39;&#39;u_split_field&#39;&#39;} is only compatible with a binary sensor mask.&#39;</span><span class="p">)</span>

        <span class="c1"># check input options for data streaming *****</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">stream_to_disk</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The optional input &#39;&#39;StreamToDisk&#39;&#39; is currently only compatible with forward simulations using a non-zero sensor mask.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">ismember</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The optional input &#39;&#39;StreamToDisk&#39;&#39; is currently only compatible with sensor.record = {&#39;&#39;p&#39;&#39;} (the default).&#39;</span><span class="p">)</span>

        <span class="c1"># make sure the PML size is smaller than the grid if PMLInside is true</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nx</span><span class="p">)))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">k_dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pml_size</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">kgrid_N</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The size of the PML must be smaller than the size of the grid.&#39;</span><span class="p">)</span>

        <span class="c1"># make sure the PML is inside if using a non-uniform grid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonuniform_grid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;&#39;PMLInside&#39;&#39; must be true for simulations using non-uniform grids.&quot;</span><span class="p">)</span>

        <span class="c1"># check for compatible input options if saving to disk</span>
        <span class="c1"># modified by Farid | disabled temporarily!</span>
        <span class="c1"># if k_dim == 3 and isinstance(self.options.save_to_disk, str) and (not self.use_sensor or not self.binary_sensor_mask or self.time_rev):</span>
        <span class="c1">#     raise ValueError(&#39;The optional input &#39;&#39;SaveToDisk&#39;&#39; is currently only compatible with forward simulations using a non-zero binary sensor mask.&#39;)</span>

        <span class="c1"># check the record start time is within range</span>
        <span class="n">record_start_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">record_start_index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="p">((</span><span class="n">record_start_index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">record_start_index</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sensor.record_start_index must be between 1 and the number of time steps.&#39;</span><span class="p">)</span>

        <span class="c1"># ensure &#39;WSWA&#39; symmetry if using axisymmetric code with &#39;SaveToDisk&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="o">!=</span> <span class="s1">&#39;WSWA&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="c1"># display a warning only if using WSWS symmetry (not WSWA-FFT)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;WSWS&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  WARNING: Optional input &#39;&#39;RadialSymmetry&#39;&#39; changed to &#39;&#39;WSWA&#39;&#39; for compatability with &#39;&#39;SaveToDisk&#39;&#39;.&#39;</span><span class="p">)</span>

            <span class="c1"># update setting</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="o">=</span> <span class="s1">&#39;WSWA&#39;</span>

        <span class="c1"># ensure p0 smoothing is switched off if p0 is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">smooth_p0</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># start log if required</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">create_log</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;diary(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">LOG_NAME</span><span class="si">}</span><span class="s2">.txt&#39;);&quot;</span><span class="p">)</span>

        <span class="c1"># update command line status</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  time reversal mode&#39;</span><span class="p">)</span>

        <span class="c1"># cleanup unused variables</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_DEF&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.smooth_and_enlarge"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.smooth_and_enlarge">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_and_enlarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">k_dim</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="n">SimulationOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth and enlarge grids</span>

<span class="sd">        Args:</span>
<span class="sd">            source: kWaveSource instance</span>
<span class="sd">            k_dim: kWaveGrid dimensionality</span>
<span class="sd">            kgrid_N: kWaveGrid size in each direction</span>
<span class="sd">            opt: SimulationOptions</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># smooth the initial pressure distribution p0 if required, and then restore</span>
        <span class="c1"># the maximum magnitude</span>
        <span class="c1">#   NOTE 1: if p0 has any values at the edge of the domain, the smoothing</span>
        <span class="c1">#   may cause part of p0 to wrap to the other side of the domain</span>
        <span class="c1">#   NOTE 2: p0 is smoothed before the grid is expanded to ensure that p0 is</span>
        <span class="c1">#   exactly zero within the PML</span>
        <span class="c1">#   NOTE 3: for the axisymmetric code, p0 is smoothed assuming WS origin</span>
        <span class="c1">#   symmetry</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">smooth_p0</span><span class="p">:</span>

            <span class="c1"># update command line status</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  smoothing p0 distribution...&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;WSWA-FFT&#39;</span><span class="p">,</span> <span class="s1">&#39;WSWA&#39;</span><span class="p">]:</span>
                    <span class="c1"># create a new kWave grid object with expanded radial grid</span>
                    <span class="n">kgrid_exp</span> <span class="o">=</span> <span class="n">kWaveGrid</span><span class="p">([</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dy</span><span class="p">])</span>

                    <span class="c1"># mirror p0 in radial dimension using WSWA symmetry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">p0_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> <span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Ny</span><span class="p">))</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>           <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;WSWS-FFT&#39;</span><span class="p">,</span> <span class="s1">&#39;WSWS&#39;</span><span class="p">]:</span>
                    <span class="c1"># create a new kWave grid object with expanded radial grid</span>
                    <span class="n">kgrid_exp</span> <span class="o">=</span> <span class="n">kWaveGrid</span><span class="p">([</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dy</span><span class="p">])</span>

                    <span class="c1"># mirror p0 in radial dimension using WSWS symmetry</span>
                    <span class="n">p0_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> <span class="n">kgrid_exp</span><span class="o">.</span><span class="n">Ny</span><span class="p">))</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>              <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">p0</span>
                    <span class="n">p0_exp</span><span class="p">[:,</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span><span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># smooth p0</span>
                <span class="n">p0_exp</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">p0_exp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

                <span class="c1"># trim back to original size</span>
                <span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">p0_exp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">Ny</span><span class="p">]</span>

                <span class="c1"># clean up unused variables</span>
                <span class="k">del</span> <span class="n">kgrid_exp</span>
                <span class="k">del</span> <span class="n">p0_exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">p0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># expand the computational grid if the PML is set to be outside the input</span>
        <span class="c1"># grid defined by the user</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">pml_inside</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">expand_results</span> <span class="o">=</span> <span class="n">expand_grid_matrices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;p_source_pos_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span><span class="p">,</span>
                    <span class="s1">&#39;u_source_pos_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span><span class="p">,</span>
                    <span class="s1">&#39;s_source_pos_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;axisymmetric&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">,</span>
                    <span class="s1">&#39;use_sensor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span><span class="p">,</span>
                    <span class="s1">&#39;blank_sensor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span><span class="p">,</span>
                    <span class="s1">&#39;cuboid_corners&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuboid_corners</span><span class="p">,</span>

                    <span class="s1">&#39;source_p0&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span><span class="p">,</span>
                    <span class="s1">&#39;source_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span><span class="p">,</span>

                    <span class="s1">&#39;source_ux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span><span class="p">,</span>
                    <span class="s1">&#39;source_uy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span><span class="p">,</span>
                    <span class="s1">&#39;source_uz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span><span class="p">,</span>

                    <span class="s1">&#39;transducer_source&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span><span class="p">,</span>

                    <span class="s1">&#39;source_sxx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxx</span><span class="p">,</span>
                    <span class="s1">&#39;source_syy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syy</span><span class="p">,</span>
                    <span class="s1">&#39;source_szz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_szz</span><span class="p">,</span>
                    <span class="s1">&#39;source_sxy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxy</span><span class="p">,</span>
                    <span class="s1">&#39;source_sxz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxz</span><span class="p">,</span>
                    <span class="s1">&#39;source_syz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syz</span>
                <span class="p">})</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="n">expand_results</span>

        <span class="c1"># get maximum prime factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">:</span>
            <span class="n">prime_facs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">highest_prime_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">radial_symmetry</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prime_facs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">highest_prime_factors</span><span class="p">()</span>

        <span class="c1"># give warning for bad dimension sizes</span>
        <span class="k">if</span> <span class="n">prime_facs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">HIGHEST_PRIME_FACTOR_WARNING</span><span class="p">:</span>
            <span class="n">prime_facs</span> <span class="o">=</span> <span class="n">prime_facs</span><span class="p">[</span><span class="n">prime_facs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: Highest prime factors in each dimension are </span><span class="si">{</span><span class="n">prime_facs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Use dimension sizes with lower prime factors to improve speed&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">prime_facs</span>

        <span class="c1"># smooth the sound speed distribution if required</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">smooth_c0</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="p">)</span> <span class="o">==</span> <span class="n">k_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  smoothing sound speed distribution...&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span><span class="p">)</span>

        <span class="c1"># smooth the ambient density distribution if required</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">smooth_rho0</span> <span class="ow">and</span> <span class="n">num_dim2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">density</span><span class="p">)</span> <span class="o">==</span> <span class="n">k_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">density</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;smoothing density distribution...&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="o">.</span><span class="n">density</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.create_sensor_variables"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.create_sensor_variables">[docs]</a>    <span class="k">def</span> <span class="nf">create_sensor_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the sensor related variables</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define the output variables and mask indices if using the sensor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuboid_corners</span><span class="p">:</span>

                    <span class="c1"># create empty list of sensor indices</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="c1"># loop through the list of cuboid corners, and extract the</span>
                    <span class="c1"># sensor mask indices for each cube</span>
                    <span class="k">for</span> <span class="n">cuboid_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>

                        <span class="c1"># create empty binary mask</span>
                        <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">cuboid_corners_list</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="n">cuboid_index</span><span class="p">]</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="c1"># extract mask indices</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matlab_find</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">)</span>

                    <span class="c1"># cleanup unused variables</span>
                    <span class="k">del</span> <span class="n">temp_mask</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># create mask indices (this works for both normal sensor and</span>
                    <span class="c1"># transducer inputs)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 due to matlab indexing</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># compatibility, n =&gt; [n, 1]</span>

                <span class="c1"># convert the data type depending on the number of indices (this saves</span>
                <span class="c1"># memory)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="n">cast_to_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_data_type</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set the sensor mask index variable to be empty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sensor_mask_index</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># run subscript to create storage variables if not saving to disk</span>
        <span class="c1"># TODO (Walter): this case is very broken but save to disk is currently always true!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sensor</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">create_storage_variables</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;binary_sensor_mask&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span><span class="p">,</span>
                    <span class="s1">&#39;time_rev&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_rev</span><span class="p">,</span>
                    <span class="s1">&#39;blank_sensor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_sensor</span><span class="p">,</span>
                    <span class="s1">&#39;record_u_split_field&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_u_split_field</span><span class="p">,</span>
                    <span class="s1">&#39;axisymmetric&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">,</span>
                    <span class="s1">&#39;reorder_data&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_data</span><span class="p">,</span>
                <span class="p">}),</span>
                <span class="n">dotdict</span><span class="p">({</span>
                    <span class="s1">&#39;sensor_x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                    <span class="s1">&#39;sensor_mask_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">mask_index</span><span class="p">,</span>
                    <span class="s1">&#39;record&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">,</span>
                    <span class="s1">&#39;sensor_data_buffer_size&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">data_buffer_size</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binary_sensor_mask</span>                 <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">binary_sensor_mask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder_data</span>                       <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reorder_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">transducer_receive_elevation_focus</span></div>

<div class="viewcode-block" id="kWaveSimulation.create_absorption_vars"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.create_absorption_vars">[docs]</a>    <span class="k">def</span> <span class="nf">create_absorption_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create absorption variables for the fluid code based on</span>
<span class="sd">        the expanded and smoothed values of the medium parameters (if not saving to disk)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_code</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">save_to_disk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorb_nabla2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorb_tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorb_eta</span> <span class="o">=</span> <span class="n">create_absorption_variables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">medium</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_of_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.assign_pseudonyms"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.assign_pseudonyms">[docs]</a>    <span class="k">def</span> <span class="nf">assign_pseudonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">medium</span><span class="p">:</span> <span class="n">kWaveMedium</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">:</span> <span class="n">kWaveGrid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorten commonly used field names (these act only as pointers provided that the values aren&#39;t modified)</span>
<span class="sd">        (done after enlarging and smoothing the grids)</span>

<span class="sd">        Args:</span>
<span class="sd">            medium: kWaveMedium instance</span>
<span class="sd">            kgrid: kWaveGrid instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kgrid</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span> <span class="o">=</span> <span class="n">medium</span><span class="o">.</span><span class="n">density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c0</span> <span class="o">=</span> <span class="n">medium</span><span class="o">.</span><span class="n">sound_speed</span></div>

<div class="viewcode-block" id="kWaveSimulation.scale_source_terms"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.scale_source_terms">[docs]</a>    <span class="k">def</span> <span class="nf">scale_source_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_scale_source_terms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale the source terms based on the expanded and smoothed values of the medium parameters</span>

<span class="sd">        Args:</span>
<span class="sd">            is_scale_source_terms: Should the source terms be scaled</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scale_source_terms</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_source_pos_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">p_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_source_pos_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">s_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_source_pos_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">u_source_pos_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span> <span class="o">=</span> <span class="n">scale_source_terms_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
            <span class="n">p_source_pos_index</span><span class="p">,</span> <span class="n">s_source_pos_index</span><span class="p">,</span> <span class="n">u_source_pos_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_input_signal</span><span class="p">,</span>
            <span class="n">dotdict</span><span class="p">({</span>
                <span class="s1">&#39;nonuniform_grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonuniform_grid</span><span class="p">,</span>
                <span class="s1">&#39;source_ux&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_ux</span><span class="p">,</span>
                <span class="s1">&#39;source_uy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uy</span><span class="p">,</span>
                <span class="s1">&#39;source_uz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_uz</span><span class="p">,</span>
                <span class="s1">&#39;transducer_source&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transducer_source</span><span class="p">,</span>
                <span class="s1">&#39;source_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p</span><span class="p">,</span>
                <span class="s1">&#39;source_p0&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_p0</span><span class="p">,</span>
                <span class="s1">&#39;use_w_source_correction_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_w_source_correction_p</span><span class="p">,</span>
                <span class="s1">&#39;use_w_source_correction_u&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_w_source_correction_u</span><span class="p">,</span>

                <span class="s1">&#39;source_sxx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxx</span><span class="p">,</span>
                <span class="s1">&#39;source_syy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syy</span><span class="p">,</span>
                <span class="s1">&#39;source_szz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_szz</span><span class="p">,</span>
                <span class="s1">&#39;source_sxy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxy</span><span class="p">,</span>
                <span class="s1">&#39;source_sxz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_sxz</span><span class="p">,</span>
                <span class="s1">&#39;source_syz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_syz</span><span class="p">,</span>
            <span class="p">})</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="kWaveSimulation.create_pml_indices"><a class="viewcode-back" href="../../kwave.kWaveSimulation.html#kwave.kWaveSimulation.kWaveSimulation.create_pml_indices">[docs]</a>    <span class="k">def</span> <span class="nf">create_pml_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kgrid_dim</span><span class="p">,</span> <span class="n">kgrid_N</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">pml_inside</span><span class="p">,</span> <span class="n">is_axisymmetric</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define index variables to remove the PML from the display if the optional</span>
<span class="sd">        input &#39;PlotPML&#39; is set to false</span>

<span class="sd">        Args:</span>
<span class="sd">            kgrid_dim: kWaveGrid dimensinality</span>
<span class="sd">            kgrid_N: kWaveGrid size in each direction</span>
<span class="sd">            pml_size: Size of the PML</span>
<span class="sd">            pml_inside: Whether the PML is inside the grid defined by the user</span>
<span class="sd">            is_axisymmetric: Whether the simulation is axisymmetric</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># comment by Farid: PlotPML is always False in Python version,</span>
        <span class="c1">#                       therefore if statement removed</span>
        <span class="k">if</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span>
        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisymmetric</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span>
        <span class="k">elif</span> <span class="n">kgrid_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="n">kgrid_N</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">pml_size</span><span class="o">.</span><span class="n">z</span>

        <span class="c1"># define index variables to allow original grid size to be maintained for</span>
        <span class="c1"># the _final and _all output variables if &#39;PMLInside&#39; is set to false</span>
        <span class="c1"># if self.record is None:</span>
        <span class="c1">#     self.record = Recorder()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="o">.</span><span class="n">set_index_variables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">pml_size</span><span class="p">,</span> <span class="n">pml_inside</span><span class="p">,</span> <span class="n">is_axisymmetric</span><span class="p">)</span></div></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Walter Simson, Farid Yagubbayli
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    </body>
</html>