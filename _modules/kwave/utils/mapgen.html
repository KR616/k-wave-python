<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>kwave.utils.mapgen - k-wave-python documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-toolbox-code.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">k-wave-python  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">k-wave-python  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/contrib.html">Contribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/development_environment.html">Development Environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">kwave</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.data.html">kwave.data module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.enums.html">kwave.enums module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.executor.html">kwave.executor module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kWaveSimulation.html">kwave.kWaveSimulation module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kgrid.html">kwave.kgrid module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kmedium.html">kwave.kmedium module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.ksensor.html">kwave.ksensor module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.ksource.html">kwave.ksource module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kspaceFirstOrder.html">kwave.kspaceFirstOrder module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kspaceFirstOrder2D.html">kwave.kspaceFirstOrder2D module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kspaceFirstOrder3D.html">kwave.kspaceFirstOrder3D module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.kspaceFirstOrderAS.html">kwave.kspaceFirstOrderAS module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.ktransducer.html">kwave.ktransducer module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.options.html">kwave.options module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kwave.recorder.html">kwave.recorder module</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../kwave.utils.html">kwave.utils package</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.checks.html">kwave.utils.checks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.colormap.html">kwave.utils.colormap module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.conversion.html">kwave.utils.conversion module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.data.html">kwave.utils.data module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.dotdictionary.html">kwave.utils.dotdictionary module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.filters.html">kwave.utils.filters module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.interp.html">kwave.utils.interp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.io.html">kwave.utils.io module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.mapgen.html">kwave.utils.mapgen module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.math.html">kwave.utils.math module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.matrix.html">kwave.utils.matrix module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.pml.html">kwave.utils.pml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.signals.html">kwave.utils.signals module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.utils.tictoc.html">kwave.utils.tictoc module</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.html">kwave.kWaveSimulation_helper package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.create_absorption_variables.html">kwave.kWaveSimulation_helper.create_absorption_variables module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.create_storage_variables.html">kwave.kWaveSimulation_helper.create_storage_variables module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.data_cast.html">kwave.kWaveSimulation_helper.data_cast module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.display_simulation_params.html">kwave.kWaveSimulation_helper.display_simulation_params module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.expand_grid_matrices.html">kwave.kWaveSimulation_helper.expand_grid_matrices module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.retract_transducer_grid_size.html">kwave.kWaveSimulation_helper.retract_transducer_grid_size module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.save_to_disk_func.html">kwave.kWaveSimulation_helper.save_to_disk_func module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.scale_source_terms_func.html">kwave.kWaveSimulation_helper.scale_source_terms_func module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.kWaveSimulation_helper.set_sound_speed_ref.html">kwave.kWaveSimulation_helper.set_sound_speed_ref module</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../kwave.reconstruction.html">kwave.reconstruction package</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.reconstruction.beamform.html">kwave.reconstruction.beamform module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.reconstruction.converter.html">kwave.reconstruction.converter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.reconstruction.shifted_transform.html">kwave.reconstruction.shifted_transform module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../kwave.reconstruction.tools.html">kwave.reconstruction.tools module</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for kwave.utils.mapgen</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

<span class="kn">from</span> <span class="nn">.conversion</span> <span class="kn">import</span> <span class="n">db2neper</span><span class="p">,</span> <span class="n">neper2db</span>
<span class="kn">from</span> <span class="nn">.data</span> <span class="kn">import</span> <span class="n">scale_SI</span>
<span class="kn">from</span> <span class="nn">.matlab</span> <span class="kn">import</span> <span class="n">matlab_assign</span><span class="p">,</span> <span class="n">matlab_find</span><span class="p">,</span> <span class="n">ind2sub</span><span class="p">,</span> <span class="n">sub2ind</span>
<span class="kn">from</span> <span class="nn">.matrix</span> <span class="kn">import</span> <span class="n">max_nd</span>
<span class="kn">from</span> <span class="nn">.tictoc</span> <span class="kn">import</span> <span class="n">TicToc</span>


<div class="viewcode-block" id="get_spaced_points"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.get_spaced_points">[docs]</a><span class="k">def</span> <span class="nf">get_spaced_points</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">spacing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a row vector of either logarithmically or linearly spaced points between `start` and `stop`.</span>

<span class="sd">    When `spacing` is set to &#39;linear&#39;, the function is identical to the inbuilt `np.linspace` function.</span>
<span class="sd">    When `spacing` is set to &#39;log&#39;, the function is similar to the inbuilt `np.logspace` function, except</span>
<span class="sd">    that `start` and `stop` define the start and end numbers, not decades. For logarithmically spaced</span>
<span class="sd">    points, `start` must be &gt; 0. If `n` &lt; 2, `stop` is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        start: start value for the spaced points</span>
<span class="sd">        stop: end value for the spaced points</span>
<span class="sd">        n: number of points to generate</span>
<span class="sd">        spacing: type of spacing to use, either &#39;linear&#39; or &#39;log&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        points: row vector of spaced points</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if `stop` &lt;= `start` or `spacing` is not &#39;linear&#39; or &#39;log&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`stop` must be larger than `start`.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spacing</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">spacing</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`spacing` </span><span class="si">{</span><span class="n">spacing</span><span class="si">}</span><span class="s2"> is not a valid argument. Choose from &#39;linear&#39; or &#39;log&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fit_power_law_params"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.fit_power_law_params">[docs]</a><span class="k">def</span> <span class="nf">fit_power_law_params</span><span class="p">(</span><span class="n">a0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">c0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">f_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">f_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">plot_fit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate absorption parameters that fit a power law over a given frequency range.</span>

<span class="sd">    This function calculates the absorption parameters that should be defined in the simulation functions</span>
<span class="sd">    to achieve the desired power law absorption behavior defined by `a0` and `y`. This takes into account</span>
<span class="sd">    the actual absorption behavior exhibited by the fractional Laplacian wave equation.</span>

<span class="sd">    This fitting is required when using large absorption values or high frequencies, as the fractional</span>
<span class="sd">    Laplacian wave equation solved in `kspaceFirstOrderND` and `kspaceSecondOrder` no longer encapsulates</span>
<span class="sd">    absorption of the form `a = a0*f^y`.</span>

<span class="sd">    The returned values should be used to define `medium.alpha_coeff` and `medium.alpha_power` within the</span>
<span class="sd">    simulation functions. The absorption behavior over the frequency range `f_min`:`f_max` will then</span>
<span class="sd">    follow the power law defined by `a0` and `y`.</span>

<span class="sd">    Args:</span>
<span class="sd">        a0: coefficient in the power law absorption equation</span>
<span class="sd">        y: exponent in the power law absorption equation</span>
<span class="sd">        c0: speed of sound in the medium</span>
<span class="sd">        f_min: minimum frequency in the range to fit the power law</span>
<span class="sd">        f_max: maximum frequency in the range to fit the power law</span>
<span class="sd">        plot_fit: whether to plot the fit</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of the absorption coefficient and fitted exponent of the power law absorption equation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># define frequency axis</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">get_spaced_points</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f</span>
    <span class="c1"># convert user defined a0 to Nepers/((rad/s)^y m)</span>
    <span class="n">a0_np</span> <span class="o">=</span> <span class="n">db2neper</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">desired_absorption</span> <span class="o">=</span> <span class="n">a0_np</span> <span class="o">*</span> <span class="n">w</span> <span class="o">**</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">abs_func</span><span class="p">(</span><span class="n">trial_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Second-order absorption error&quot;&quot;&quot;</span>
        <span class="n">a0_np_trial</span><span class="p">,</span> <span class="n">y_trial</span> <span class="o">=</span> <span class="n">trial_vals</span>

        <span class="n">actual_absorption</span> <span class="o">=</span> <span class="n">a0_np_trial</span> <span class="o">*</span> <span class="n">w</span> <span class="o">**</span> <span class="n">y_trial</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">y_trial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                                                          <span class="n">a0_np_trial</span> <span class="o">*</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">y_trial</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span> <span class="o">**</span> <span class="p">(</span>
                                                                  <span class="n">y_trial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">absorption_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">desired_absorption</span> <span class="o">-</span> <span class="n">actual_absorption</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">absorption_error</span>

    <span class="n">a0_np_fit</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">abs_func</span><span class="p">,</span> <span class="p">[</span><span class="n">a0_np</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

    <span class="n">a0_fit</span> <span class="o">=</span> <span class="n">neper2db</span><span class="p">(</span><span class="n">a0_np_fit</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_fit</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">return</span> <span class="n">a0_fit</span><span class="p">,</span> <span class="n">y_fit</span></div>


<div class="viewcode-block" id="power_law_kramers_kronig"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.power_law_kramers_kronig">[docs]</a><span class="k">def</span> <span class="nf">power_law_kramers_kronig</span><span class="p">(</span><span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">c0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">a0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the variation in sound speed for an attenuating medium using the Kramers-Kronig for power law attenuation.</span>

<span class="sd">    This function computes the variation in sound speed for an attenuating medium using the Kramers-Kronig</span>
<span class="sd">    formula for power law attenuation, where `att = a0 * w^y`. The power law parameters must be in Nepers/m,</span>
<span class="sd">    with the frequency in rad/s. The variation is given about the sound speed `c0` at a reference frequency `w0`.</span>

<span class="sd">    Args:</span>
<span class="sd">        w: input frequency array [rad/s]</span>
<span class="sd">        w0: reference frequency [rad/s]</span>
<span class="sd">        c0: sound speed at w0 [m/s]</span>
<span class="sd">        a0: power law coefficient [Nepers/((rad/s)^y m)]</span>
<span class="sd">        y: power law exponent, where 0 &lt; y &lt; 3</span>

<span class="sd">    Returns:</span>
<span class="sd">        Variation of sound speed with w [m/s]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="mi">0</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;y must be within the interval (0,3)&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="n">c_kk</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Kramers-Kronig for y = 1</span>
        <span class="n">c_kk</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="n">w0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Kramers-Kronig for 0 &lt; y &lt; 1 and 1 &lt; y &lt; 3</span>
        <span class="n">c_kk</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">**</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">w0</span> <span class="o">**</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">c_kk</span></div>


<div class="viewcode-block" id="water_absorption"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.water_absorption">[docs]</a><span class="k">def</span> <span class="nf">water_absorption</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">temp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the ultrasonic absorption in distilled</span>
<span class="sd">    water at a given temperature and frequency using a 7 th order</span>
<span class="sd">    polynomial fitted to the data given by np.pinkerton(1949).</span>


<span class="sd">    Args:</span>
<span class="sd">        f:   f frequency value [MHz]</span>
<span class="sd">        T:   water temperature value [degC]</span>

<span class="sd">    Returns:</span>
<span class="sd">        abs:  absorption [dB / cm]</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; abs = waterAbsorption(f, T)</span>

<span class="sd">    References:</span>
<span class="sd">        [1] np.pinkerton(1949) &quot;The Absorption of Ultrasonic Waves in Liquids</span>
<span class="sd">        and its Relation to Molecular Constitution, &quot; Proceedings of the</span>
<span class="sd">        Physical Society.Section B, 2, 129 - 141</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NEPER2DB</span> <span class="o">=</span> <span class="mf">8.686</span>
    <span class="c1"># check temperature is within range</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">60</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s2">&quot;Temperature outside range of experimental data&quot;</span><span class="p">)</span>

    <span class="c1"># conversion factor between Nepers and dB NEPER2DB = 8.686;</span>
    <span class="c1"># coefficients for 7th order polynomial fit</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">56.723531840522710</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.899633796917384</span><span class="p">,</span> <span class="mf">0.099253401567561</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.002067402501557</span><span class="p">,</span> <span class="mf">2.189417428917596e-005</span><span class="p">,</span>
         <span class="o">-</span><span class="mf">6.210860973978427e-008</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.402634551821596e-010</span><span class="p">,</span> <span class="mf">3.869387679459408e-012</span><span class="p">]</span>

    <span class="c1"># compute absorption</span>
    <span class="n">a_on_fsqr</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span>
        <span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-17</span>

    <span class="nb">abs</span> <span class="o">=</span> <span class="n">NEPER2DB</span> <span class="o">*</span> <span class="mf">1e12</span> <span class="o">*</span> <span class="n">f</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a_on_fsqr</span>
    <span class="k">return</span> <span class="nb">abs</span></div>


<div class="viewcode-block" id="water_sound_speed"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.water_sound_speed">[docs]</a><span class="k">def</span> <span class="nf">water_sound_speed</span><span class="p">(</span><span class="n">temp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the sound speed in distilled water with temperature.</span>

<span class="sd">    Args:</span>
<span class="sd">        temp: The temperature of the water in degrees Celsius.</span>

<span class="sd">    Returns:</span>
<span class="sd">        c: The sound speed in distilled water in m/s.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if `temp` is not between 0 and 95</span>

<span class="sd">    References:</span>
<span class="sd">        Marczak, R. (1997). The sound velocity in water as a function of temperature. Journal of Research of the National Institute of Standards and Technology, 102(6), 561-567.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check limits</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">95</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`temp` must be between 0 and 95.&quot;</span><span class="p">)</span>

    <span class="c1"># find value</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.787860e-9</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.398845e-6</span><span class="p">,</span> <span class="mf">3.287156e-4</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.779136e-2</span><span class="p">,</span> <span class="mf">5.038813</span><span class="p">,</span> <span class="mf">1.402385e3</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="water_density"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.water_density">[docs]</a><span class="k">def</span> <span class="nf">water_density</span><span class="p">(</span><span class="n">temp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the density of air-saturated water with temperature.</span>

<span class="sd">    This function calculates the density of air-saturated water at a given temperature using the 4th order polynomial</span>
<span class="sd">    given by Jones [1].</span>

<span class="sd">    Args:</span>
<span class="sd">        temp: water temperature in the range 5 to 40 [degC]</span>

<span class="sd">    Returns:</span>
<span class="sd">        density: density of water [kg/m^3]</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if `temp` is not between 5 and 40</span>

<span class="sd">    References:</span>
<span class="sd">        [1] F.E. Jones and G.L. Harris (1992) &quot;ITS-90 Density of Water Formulation for Volumetric Standards Calibration,&quot;</span>
<span class="sd">        J. Res. Natl. Inst.Stand.Technol., 97(3), 335-340.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check limits</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">5</span> <span class="o">&lt;=</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">40</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`temp` must be between 5 and 40.&quot;</span><span class="p">)</span>

    <span class="c1"># calculate density of air-saturated water</span>
    <span class="n">density</span> <span class="o">=</span> <span class="mf">999.84847</span> <span class="o">+</span> <span class="mf">6.337563e-2</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">-</span> <span class="mf">8.523829e-3</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">6.943248e-5</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span> <span class="mf">3.821216e-7</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">**</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">density</span></div>


<div class="viewcode-block" id="water_non_linearity"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.water_non_linearity">[docs]</a><span class="k">def</span> <span class="nf">water_non_linearity</span><span class="p">(</span><span class="n">temp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Calculates the parameter of nonlinearity B/A at a</span>
<span class="sd">     given temperature using a fourth-order polynomial fitted to the data</span>
<span class="sd">     given by Beyer (1960).</span>

<span class="sd">    Args:</span>
<span class="sd">        temp: water temperature in the range 0 to 100 [degC]</span>

<span class="sd">    Returns:</span>
<span class="sd">        BonA: parameter of nonlinearity</span>

<span class="sd">    Examples:</span>
<span class="sd">         &gt;&gt;&gt; BonA = waterNonlinearity(T)</span>

<span class="sd">     References:</span>
<span class="sd">         [1] R. T Beyer (1960) &quot;Parameter of nonlinearity in fluids,&quot; J.</span>
<span class="sd">         Acoust. Soc. Am., 32(6), 719-721.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check limits</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">,</span> <span class="s2">&quot;Temp must be between 0 and 100.&quot;</span>

    <span class="c1"># find value</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.587913769504693e-08</span><span class="p">,</span> <span class="mf">1.047843302423604e-05</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.355518377254833e-04</span><span class="p">,</span> <span class="mf">5.380874771364909e-2</span><span class="p">,</span> <span class="mf">4.186533937275504</span><span class="p">]</span>
    <span class="n">BonA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BonA</span></div>


<span class="c1"># TODO: refactor to take 3 dimensional arrays</span>
<div class="viewcode-block" id="make_ball"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_ball">[docs]</a><span class="k">def</span> <span class="nf">make_ball</span><span class="p">(</span><span class="n">Nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Ny</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Nz</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cy</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cz</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">plot_ball</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a binary map of a filled ball within a 3D grid.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: size of the 3D grid in x-dimension [grid points].</span>
<span class="sd">        Ny: size of the 3D grid in y-dimension [grid points].</span>
<span class="sd">        Nz: size of the 3D grid in z-dimension [grid points].</span>
<span class="sd">        cx: centre of the ball in x-dimension [grid points].</span>
<span class="sd">        cy: centre of the ball in y-dimension [grid points].</span>
<span class="sd">        cz: centre of the ball in z-dimension [grid points].</span>
<span class="sd">        radius: ball radius [grid points].</span>
<span class="sd">        plot_ball: whether to plot the ball using voxelPlot (default = False).</span>
<span class="sd">        binary: whether to return the ball map as a double precision matrix (False) or a logical matrix (True) (default = False).</span>

<span class="sd">    Returns:</span>
<span class="sd">        ball: 3D binary map of a filled ball.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># define literals</span>
    <span class="n">MAGNITUDE</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># force integer values</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Ny</span><span class="p">))</span>
    <span class="n">Nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nz</span><span class="p">))</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cx</span><span class="p">))</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cy</span><span class="p">))</span>
    <span class="n">cz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cz</span><span class="p">))</span>

    <span class="c1"># check for zero values</span>
    <span class="k">if</span> <span class="n">cx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">cy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">cz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Nz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># create empty matrix</span>
    <span class="n">ball</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span> <span class="k">if</span> <span class="n">binary</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># define np.pixel map</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">make_pixel_map</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span> <span class="s1">&#39;Shift&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># create ball</span>
    <span class="n">ball</span><span class="p">[</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAGNITUDE</span>

    <span class="c1"># shift centre</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">cy</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">cz</span> <span class="o">=</span> <span class="n">cz</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">ball</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">ball</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># plot results</span>
    <span class="k">if</span> <span class="n">plot_ball</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># voxelPlot(double(ball))</span>
    <span class="k">return</span> <span class="n">ball</span></div>


<div class="viewcode-block" id="make_cart_sphere"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_cart_sphere">[docs]</a><span class="k">def</span> <span class="nf">make_cart_sphere</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">center_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                     <span class="n">plot_sphere</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cart_sphere creates a set of points in Cartesian coordinates defining a sphere.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius: the radius of the sphere.</span>
<span class="sd">        num_points: the number of points to be generated.</span>
<span class="sd">        center_pos: the coordinates of the center of the sphere. Defaults to (0, 0, 0).</span>
<span class="sd">        plot_sphere: whether to plot the sphere. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The points on the sphere.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">center_pos</span>

    <span class="c1"># generate angle functions using the Golden Section Spiral method</span>
    <span class="n">inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
    <span class="n">off</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">num_points</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">off</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">inc</span>

    <span class="c1"># create the sphere</span>
    <span class="n">sphere</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]])</span>

    <span class="c1"># offset if needed</span>
    <span class="n">sphere</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">cx</span>
    <span class="n">sphere</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">cy</span>
    <span class="n">sphere</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">cz</span>

    <span class="c1"># plot results</span>
    <span class="k">if</span> <span class="n">plot_sphere</span><span class="p">:</span>
        <span class="c1"># select suitable axis scaling factor</span>
        <span class="p">[</span><span class="n">x_sc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_SI</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sphere</span><span class="p">))</span>

        <span class="c1"># create the figure</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;seaborn-poster&#39;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot3D</span><span class="p">(</span><span class="n">sphere</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">sphere</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">sphere</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> m]&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> m]&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> m]&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">sphere</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="make_cart_circle"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_cart_circle">[docs]</a><span class="k">def</span> <span class="nf">make_cart_circle</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">center_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                     <span class="n">arc_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">plot_circle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a set of points in cartesian coordinates defining a circle or arc.</span>

<span class="sd">    This function creates a set of points in cartesian coordinates defining a circle or arc.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius: radius of the circle or arc</span>
<span class="sd">        num_points: number of points to generate</span>
<span class="sd">        center_pos: center position of the circle or arc</span>
<span class="sd">        arc_angle: arc angle in radians</span>
<span class="sd">        plot_circle: whether to plot the circle or arc</span>

<span class="sd">    Returns:</span>
<span class="sd">        2 x `num_points` array of cartesian coordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check for arc_angle input</span>
    <span class="k">if</span> <span class="n">arc_angle</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">full_circle</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">full_circle</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">cx</span> <span class="o">=</span> <span class="n">center_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">center_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">n_steps</span> <span class="o">=</span> <span class="n">num_points</span> <span class="k">if</span> <span class="n">full_circle</span> <span class="k">else</span> <span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># create angles</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span> <span class="o">*</span> <span class="n">arc_angle</span> <span class="o">/</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># create cartesian grid</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])])</span>

    <span class="c1"># offset if needed</span>
    <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">cx</span>
    <span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">cy</span>

    <span class="c1"># plot results</span>
    <span class="k">if</span> <span class="n">plot_circle</span><span class="p">:</span>
        <span class="c1"># select suitable axis scaling factor</span>
        <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_SI</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">circle</span><span class="p">)))</span>

        <span class="c1"># create the figure</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="s1">&#39;b.&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;y-position [</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> m]&quot;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;x-position [</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> m]&quot;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_disc"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_disc">[docs]</a><span class="k">def</span> <span class="nf">make_disc</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">plot_disc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a binary map of a filled disc within a 2D grid.</span>

<span class="sd">    This function creates a binary map of a filled disc within a two-dimensional grid. The disc position is denoted by 1&#39;s</span>
<span class="sd">    in the matrix with 0&#39;s elsewhere. A single grid point is taken as the disc centre, so the total diameter of the disc</span>
<span class="sd">    will always be an odd number of grid points. If used within a k-Wave grid where dx != dy, the disc will appear oval</span>
<span class="sd">    shaped. If part of the disc overlaps the grid edge, the rest of the disc will wrap to the grid edge on the opposite</span>
<span class="sd">    side.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: The number of grid points along the x-axis.</span>
<span class="sd">        Ny: The number of grid points along the y-axis.</span>
<span class="sd">        cx: The x-coordinate of the disc centre.</span>
<span class="sd">        cy: The y-coordinate of the disc centre.</span>
<span class="sd">        radius: The radius of the disc.</span>
<span class="sd">        plot_disc: If set to True, the disc will be plotted using Matplotlib.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A binary map of the disc in the 2D grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># define literals</span>
    <span class="n">MAGNITUDE</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># force integer values</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Ny</span><span class="p">))</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cx</span><span class="p">))</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cy</span><span class="p">))</span>

    <span class="c1"># check for zero values</span>
    <span class="k">if</span> <span class="n">cx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">cy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># check the inputs</span>
    <span class="k">assert</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cx</span> <span class="o">&lt;</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cy</span> <span class="o">&lt;</span> <span class="n">Ny</span><span class="p">),</span> <span class="s1">&#39;Disc center must be within grid.&#39;</span>

    <span class="c1"># create empty matrix</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>

    <span class="c1"># define np.pixel map</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">make_pixel_map</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Shift&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># create disc</span>
    <span class="n">disc</span><span class="p">[</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAGNITUDE</span>

    <span class="c1"># shift centre</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">cy</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">disc</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># create the figure</span>
    <span class="k">if</span> <span class="n">plot_disc</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="n">disc</span></div>


<div class="viewcode-block" id="make_circle"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_circle">[docs]</a><span class="k">def</span> <span class="nf">make_circle</span><span class="p">(</span><span class="n">Nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Ny</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">cy</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arc_angle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">plot_circle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a binary map of a circle within a 2D grid.</span>

<span class="sd">    This function creates a binary map of a circle (or arc) using the midpoint circle algorithm within a two-dimensional grid.</span>
<span class="sd">    The circle position is denoted by 1&#39;s in the matrix with 0&#39;s elsewhere. A single grid point is taken as the circle</span>
<span class="sd">    centre, so the total diameter will always be an odd number of grid points. The centre of the circle and the radius</span>
<span class="sd">    are not constrained by the grid dimensions, so it is possible to create sections of circles or a blank image if none</span>
<span class="sd">    of the circle intersects the grid.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: The number of grid points along the x-axis.</span>
<span class="sd">        Ny: The number of grid points along the y-axis.</span>
<span class="sd">        cx: The x-coordinate of the circle centre.</span>
<span class="sd">        cy: The y-coordinate of the circle centre.</span>
<span class="sd">        radius: The radius of the circle.</span>
<span class="sd">        arc_angle: The angle of the circular arc in degrees. If set to None, a full circle will be created.</span>
<span class="sd">        plot_circle: If set to True, the circle will be plotted using Matplotlib.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A binary map of the circle in the 2D grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># define literals</span>
    <span class="n">MAGNITUDE</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">arc_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arc_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">elif</span> <span class="n">arc_angle</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">arc_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">elif</span> <span class="n">arc_angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">arc_angle</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># force integer values</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">Ny</span><span class="p">))</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cx</span><span class="p">))</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cy</span><span class="p">))</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>

    <span class="c1"># check for zero values</span>
    <span class="k">if</span> <span class="n">cx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">cy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># create empty matrix</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># initialise loop variables</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">radius</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">radius</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cx</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cx</span> <span class="o">&lt;=</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">cy</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">cy</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Ny</span><span class="p">):</span>
        <span class="n">circle</span><span class="p">[</span><span class="n">cx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAGNITUDE</span>

    <span class="c1"># draw the remaining cardinal points</span>
    <span class="n">px</span> <span class="o">=</span> <span class="p">[</span><span class="n">cx</span><span class="p">,</span> <span class="n">cx</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
    <span class="n">py</span> <span class="o">=</span> <span class="p">[</span><span class="n">cy</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cy</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">point_index</span><span class="p">,</span> <span class="p">(</span><span class="n">px_i</span><span class="p">,</span> <span class="n">py_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">)):</span>
        <span class="c1"># check whether the point is within the arc made by arc_angle, and lies</span>
        <span class="c1"># within the grid</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">px_i</span> <span class="o">-</span> <span class="n">cx</span><span class="p">,</span> <span class="n">py_i</span> <span class="o">-</span> <span class="n">cy</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">arc_angle</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">px_i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">px_i</span> <span class="o">&lt;=</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">py_i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">py_i</span> <span class="o">&lt;=</span> <span class="n">Ny</span><span class="p">):</span>
                <span class="n">circle</span><span class="p">[</span><span class="n">px_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">py_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAGNITUDE</span>

    <span class="c1"># loop through the remaining points using the midpoint circle algorithm</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span>

        <span class="c1"># setup point indices (break coding standard for readability)</span>
        <span class="n">px</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span> <span class="o">+</span> <span class="n">cx</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">]</span>
        <span class="n">py</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">cy</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">]</span>

        <span class="c1"># loop through each point</span>
        <span class="k">for</span> <span class="n">point_index</span><span class="p">,</span> <span class="p">(</span><span class="n">px_i</span><span class="p">,</span> <span class="n">py_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">)):</span>

            <span class="c1"># check whether the point is within the arc made by arc_angle, and</span>
            <span class="c1"># lies within the grid</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">px_i</span> <span class="o">-</span> <span class="n">cx</span><span class="p">,</span> <span class="n">py_i</span> <span class="o">-</span> <span class="n">cy</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">arc_angle</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">px_i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">px_i</span> <span class="o">&lt;=</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">py_i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">py_i</span> <span class="o">&lt;=</span> <span class="n">Ny</span><span class="p">):</span>
                    <span class="n">circle</span><span class="p">[</span><span class="n">px_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">py_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAGNITUDE</span>

    <span class="k">if</span> <span class="n">plot_circle</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray_r&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x-position [grid points]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;y-position [grid points]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">circle</span></div>


<div class="viewcode-block" id="make_pixel_map"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_pixel_map">[docs]</a><span class="k">def</span> <span class="nf">make_pixel_map</span><span class="p">(</span><span class="n">Nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Ny</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Nz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a matrix with values of the distance of each pixel from the center of a grid.</span>

<span class="sd">    This function generates a matrix populated with values of how far each pixel in a grid is from the center. The center</span>
<span class="sd">    can be a single pixel or a double pixel, and the optional input parameter &#39;OriginSize&#39; controls this. For grids where</span>
<span class="sd">    the dimension size and center pixel size are not both odd or even, the optional input parameter &#39;Shift&#39; can be used to</span>
<span class="sd">    control the location of the center point.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: number of pixels in the x-dimension</span>
<span class="sd">        Ny: number of pixels in the y-dimension</span>
<span class="sd">        Nz: number of pixels in the z-dimension</span>
<span class="sd">        *args: additional optional arguments</span>

<span class="sd">    Returns:</span>
<span class="sd">        r: pixel-radius</span>

<span class="sd">    Examples:</span>

<span class="sd">        Single pixel origin size for odd and even (with &#39;Shift&#39; = [1 1] and</span>
<span class="sd">        [0 0], respectively) grid sizes:</span>

<span class="sd">         x x x       x x x x         x x x x</span>
<span class="sd">         x 0 x       x x x x         x 0 x x</span>
<span class="sd">         x x x       x x 0 x         x x x x</span>
<span class="sd">                     x x x x         x x x x</span>

<span class="sd">         Double pixel origin size for even and odd (with &#39;Shift&#39; = [1 1] and</span>
<span class="sd">         [0 0], respectively) grid sizes:</span>

<span class="sd">         x x x x      x x x x x        x x x x x</span>
<span class="sd">         x 0 0 x      x x x x x        x 0 0 x x</span>
<span class="sd">         x 0 0 x      x x 0 0 x        x 0 0 x x</span>
<span class="sd">         x x x x      x x 0 0 x        x x x x x</span>
<span class="sd">                      x x x x x        x x x x x</span>

<span class="sd">         By default, a single pixel centre is used which is shifted towards</span>
<span class="sd">         the final row and column.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># define defaults</span>
    <span class="n">origin_size</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
    <span class="n">shift_def</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># detect whether the inputs are for two or three dimensions</span>
    <span class="k">if</span> <span class="n">Nz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">map_dimension</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="n">shift_def</span><span class="p">,</span> <span class="n">shift_def</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">map_dimension</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="n">shift_def</span><span class="p">,</span> <span class="n">shift_def</span><span class="p">,</span> <span class="n">shift_def</span><span class="p">]</span>

    <span class="c1"># replace with user defined values if provided</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Optional inputs must be entered as param, value pairs.&#39;</span>
        <span class="k">for</span> <span class="n">input_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Shift&#39;</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">input_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;OriginSize&#39;</span><span class="p">:</span>
                <span class="n">origin_size</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">input_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown optional input.&#39;</span><span class="p">)</span>

    <span class="c1"># catch input errors</span>
    <span class="k">assert</span> <span class="n">origin_size</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="s1">&#39;double&#39;</span><span class="p">],</span> <span class="s1">&#39;Unknown setting for optional input Center.&#39;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">shift</span><span class="p">)</span> <span class="o">==</span> <span class="n">map_dimension</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Optional input Shift must have </span><span class="si">{</span><span class="n">map_dimension</span><span class="si">}</span><span class="s1"> elements for </span><span class="si">{</span><span class="n">map_dimension</span><span class="si">}</span><span class="s1"> dimensional input parameters.&#39;</span>

    <span class="k">if</span> <span class="n">map_dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># create the maps for each dimension</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">create_pixel_dim</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">origin_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">create_pixel_dim</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">origin_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># create plaid grids</span>
        <span class="n">r_x</span><span class="p">,</span> <span class="n">r_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

        <span class="c1"># extract the pixel radius</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">r_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">r_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">map_dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># create the maps for each dimension</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">create_pixel_dim</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">origin_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">create_pixel_dim</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">origin_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">create_pixel_dim</span><span class="p">(</span><span class="n">Nz</span><span class="p">,</span> <span class="n">origin_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># create plaid grids</span>
        <span class="n">r_x</span><span class="p">,</span> <span class="n">r_y</span><span class="p">,</span> <span class="n">r_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

        <span class="c1"># extract the pixel radius</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">r_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">r_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">r_z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="create_pixel_dim"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.create_pixel_dim">[docs]</a><span class="k">def</span> <span class="nf">create_pixel_dim</span><span class="p">(</span><span class="n">Nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">origin_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an array of pixel dimensions and a pixel size.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: The number of pixels in the x-dimension.</span>
<span class="sd">        origin_size: The size of the origin in the x-dimension.</span>
<span class="sd">        shift: The shift of the pixels in the x-dimension.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The pixel dimensions.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Nested function to create the pixel radius variable</span>

    <span class="c1"># grid dimension has an even number of points</span>
    <span class="k">if</span> <span class="n">Nx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># pixel numbering has a single centre point</span>
        <span class="k">if</span> <span class="n">origin_size</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>

            <span class="c1"># centre point is shifted towards the final pixel</span>
            <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># centre point is shifted towards the first pixel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># pixel numbering has a double centre point</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>

    <span class="c1"># grid dimension has an odd number of points</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># pixel numbering has a single centre point</span>
        <span class="k">if</span> <span class="n">origin_size</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># pixel numbering has a double centre point</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># centre point is shifted towards the final pixel</span>
            <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>

            <span class="c1"># centre point is shifted towards the first pixel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">nx</span></div>


<div class="viewcode-block" id="make_line"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_line">[docs]</a><span class="k">def</span> <span class="nf">make_line</span><span class="p">(</span>
        <span class="n">Nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">Ny</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">startpoint</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">angle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a line shape with a given start and end point, angle, or length.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: The number of pixels in the x-dimension.</span>
<span class="sd">        Ny: The number of pixels in the y-dimension.</span>
<span class="sd">        startpoint: The start point of the line, given as a tuple of x and y coordinates.</span>
<span class="sd">        endpoint: The end point of the line, given as a tuple of x and y coordinates. If not specified, the line is drawn from the start point at a given angle and length.</span>
<span class="sd">        angle: The angle of the line in radians, measured counterclockwise from the x-axis. If not specified, the line is drawn from the start point to the end point.</span>
<span class="sd">        length: The length of the line in pixels. If not specified, the line is drawn from the start point to the end point.</span>

<span class="sd">    Returns:</span>
<span class="sd">        line: A 2D array of the same size as the input parameters, with a value of 1 for pixels that are part of the line and 0 for pixels that are not.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">startpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">startpoint</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">startpoint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;startpoint should be a two-element vector.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">startpoint</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Nx</span> <span class="ow">or</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Ny</span><span class="p">:</span>
        <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The starting point must lie within the grid, between [1 1] and [Nx Ny].&#39;</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># LINE BETWEEN TWO POINTS OR ANGLED LINE?</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">linetype</span> <span class="o">=</span> <span class="s1">&#39;AtoB&#39;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">startpoint</span><span class="p">,</span> <span class="n">endpoint</span>

        <span class="c1"># Addition =&gt; Fix Matlab2Python indexing</span>
        <span class="n">a</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">b</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">linetype</span> <span class="o">=</span> <span class="s1">&#39;angled&#39;</span>
        <span class="n">angle</span><span class="p">,</span> <span class="n">linelength</span> <span class="o">=</span> <span class="n">angle</span><span class="p">,</span> <span class="n">length</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># MORE INPUT CHECKING</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">if</span> <span class="n">linetype</span> <span class="o">==</span> <span class="s1">&#39;AtoB&#39;</span><span class="p">:</span>

        <span class="c1"># a and b must be different points</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The first and last points cannot be the same.&#39;</span><span class="p">)</span>

        <span class="c1"># end point must be a two-element row vector</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;endpoint should be a two-element vector.&#39;</span><span class="p">)</span>

        <span class="c1"># a and b must be within the grid</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xx</span> <span class="o">&gt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">yy</span> <span class="o">&gt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Both the start and end points must lie within the grid.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linetype</span> <span class="o">==</span> <span class="s1">&#39;angled&#39;</span><span class="p">:</span>

        <span class="c1"># angle must lie between -np.pi and np.pi</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># CALCULATE A LINE FROM A TO B</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">if</span> <span class="n">linetype</span> <span class="o">==</span> <span class="s1">&#39;AtoB&#39;</span><span class="p">:</span>

        <span class="c1"># define an empty grid to hold the line</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>

        <span class="c1"># find the equation of the line</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># gradient of the line</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># where the line crosses the y axis</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># start at the end with the smallest value of x</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">x_end</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">x_end</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># fill in the first point</span>
            <span class="n">line</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x_end</span><span class="p">:</span>
                <span class="c1"># next points to try are</span>
                <span class="n">poss_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">poss_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># find the point closest to the line</span>
                <span class="n">true_y</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">poss_x</span> <span class="o">+</span> <span class="n">c</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_y</span> <span class="o">-</span> <span class="n">true_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># the next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">poss_x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">poss_y</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>

            <span class="c1"># start at the end with the smallest value of y</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y_end</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y_end</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># fill in the first point</span>
            <span class="n">line</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y_end</span><span class="p">:</span>
                <span class="c1"># next points to try are</span>
                <span class="n">poss_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">poss_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># find the point closest to the line</span>
                <span class="n">true_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_y</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_x</span> <span class="o">-</span> <span class="n">true_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># the next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">poss_x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">poss_y</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># m = +-Inf</span>

            <span class="c1"># start at the end with the smallest value of y</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y_end</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y_end</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># fill in the first point</span>
            <span class="n">line</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y_end</span><span class="p">:</span>
                <span class="c1"># next point</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># CALCULATE AN ANGLED LINE</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">elif</span> <span class="n">linetype</span> <span class="o">==</span> <span class="s1">&#39;angled&#39;</span><span class="p">:</span>

        <span class="c1"># define an empty grid to hold the line</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>

        <span class="c1"># start at the atart</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">startpoint</span>

        <span class="c1"># fill in the first point</span>
        <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># initialise the current length of the line</span>
        <span class="n">line_length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next point</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">Ny</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>

            <span class="c1"># define the equation of the line</span>
            <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># gradient of the line</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1"># where the line crosses the y axis</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next points to try are</span>
                <span class="n">poss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
                <span class="n">poss_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># find the point closest to the line</span>
                <span class="n">true_y</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">poss_x</span> <span class="o">+</span> <span class="n">c</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_y</span> <span class="o">-</span> <span class="n">true_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># the next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">poss_x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">poss_y</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="c1"># define the equation of the line</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span>  <span class="c1"># gradient of the line</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1"># where the line crosses the y axis</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next points to try are</span>
                <span class="n">poss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
                <span class="n">poss_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># find the point closest to the line</span>
                <span class="n">true_y</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">poss_x</span> <span class="o">+</span> <span class="n">c</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_y</span> <span class="o">-</span> <span class="n">true_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># the next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">poss_x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">poss_y</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next point</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>

            <span class="c1"># define the equation of the line</span>
            <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">angle</span><span class="p">)</span>  <span class="c1"># gradient of the line</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1"># where the line crosses the y axis</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next points to try are</span>
                <span class="n">poss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
                <span class="n">poss_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># find the point closest to the line</span>
                <span class="n">true_y</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">poss_x</span> <span class="o">+</span> <span class="n">c</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_y</span> <span class="o">-</span> <span class="n">true_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># the next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">poss_x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">poss_y</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">Nx</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>

            <span class="c1"># define the equation of the line</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="o">-</span><span class="n">angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># gradient of the line</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1"># where the line crosses the y axis</span>

            <span class="k">while</span> <span class="n">line_length</span> <span class="o">&lt;</span> <span class="n">linelength</span><span class="p">:</span>

                <span class="c1"># next points to try are</span>
                <span class="n">poss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
                <span class="n">poss_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># find the point closest to the line</span>
                <span class="n">true_y</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">poss_x</span> <span class="o">+</span> <span class="n">c</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">poss_y</span> <span class="o">-</span> <span class="n">true_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">diff</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># the next point</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">poss_x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">poss_y</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># stop the points incrementing at the edges</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">Ny</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c1"># add the point to the line</span>
                <span class="n">line</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># calculate the current length of the line</span>
                <span class="n">line_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">startpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">line</span></div>


<div class="viewcode-block" id="make_arc"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_arc">[docs]</a><span class="k">def</span> <span class="nf">make_arc</span><span class="p">(</span><span class="n">grid_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">arc_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">diameter</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
             <span class="n">focus_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates an arc shape with a given radius, diameter, and focus position.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_size: The size of the grid, given as a 1D array with the number of pixels in each dimension.</span>
<span class="sd">        arc_pos: The position of the arc, given as a 1D array with the coordinates in each dimension.</span>
<span class="sd">        radius: The radius of the arc.</span>
<span class="sd">        diameter: The diameter of the arc.</span>
<span class="sd">        focus_pos: The position of the focus, given as a 1D array with the coordinates in each dimension.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A 2D array with the arc shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># force integer input values</span>
    <span class="n">grid_size</span> <span class="o">=</span> <span class="n">grid_size</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">arc_pos</span> <span class="o">=</span> <span class="n">arc_pos</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">diameter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">diameter</span><span class="p">))</span>
    <span class="n">focus_pos</span> <span class="o">=</span> <span class="n">focus_pos</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>

    <span class="c1"># check the input ranges</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">grid_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The grid size must be positive.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The radius must be positive.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diameter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The diameter must be positive.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arc_pos</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arc_pos</span> <span class="o">&gt;</span> <span class="n">grid_size</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The centre of the arc must be within the grid.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diameter</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The diameter of the arc must be less than twice the radius of curvature.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diameter</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The diameter must be an odd number of grid points.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">arc_pos</span> <span class="o">==</span> <span class="n">focus_pos</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The focus_pos must be different to the arc_pos.&#39;</span><span class="p">)</span>

    <span class="c1"># assign variable names to vector components</span>
    <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">grid_size</span>
    <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span> <span class="o">=</span> <span class="n">arc_pos</span>
    <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span> <span class="o">=</span> <span class="n">focus_pos</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># CREATE ARC</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>

        <span class="c1"># find half the arc angle</span>
        <span class="n">half_arc_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">radius</span><span class="p">)</span>

        <span class="c1"># find centre of circle on which the arc lies</span>
        <span class="n">distance_cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">ax</span> <span class="o">-</span> <span class="n">fx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ay</span> <span class="o">-</span> <span class="n">fy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">radius</span> <span class="o">/</span> <span class="n">distance_cf</span> <span class="o">*</span> <span class="p">(</span><span class="n">fx</span> <span class="o">-</span> <span class="n">ax</span><span class="p">)</span> <span class="o">+</span> <span class="n">ax</span><span class="p">)</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">radius</span> <span class="o">/</span> <span class="n">distance_cf</span> <span class="o">*</span> <span class="p">(</span><span class="n">fy</span> <span class="o">-</span> <span class="n">ay</span><span class="p">)</span> <span class="o">+</span> <span class="n">ay</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">])</span>

        <span class="c1"># create circle</span>
        <span class="n">arc</span> <span class="o">=</span> <span class="n">make_circle</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>

        <span class="c1"># form vector from the geometric arc centre to the arc midpoint</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">arc_pos</span> <span class="o">-</span> <span class="n">c</span>

        <span class="c1"># calculate length of vector</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">arc_pos</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># extract all points that form part of the arc</span>
        <span class="n">arc_ind</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># loop through the arc points</span>
        <span class="k">for</span> <span class="n">arc_ind_i</span> <span class="ow">in</span> <span class="n">arc_ind</span><span class="p">:</span>

            <span class="c1"># extract the indices of the current point</span>
            <span class="n">x_ind</span><span class="p">,</span> <span class="n">y_ind</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">],</span> <span class="n">arc_ind_i</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_ind</span><span class="p">,</span> <span class="n">y_ind</span><span class="p">])</span>

            <span class="c1"># form vector from the geometric arc centre to the current point</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">c</span>

            <span class="c1"># calculate length of vector</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

            <span class="c1"># find the angle between the two vectors using the dot product,</span>
            <span class="c1"># normalised using the vector lengths</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">v1</span> <span class="o">*</span> <span class="n">v2</span> <span class="o">/</span> <span class="p">(</span><span class="n">l1</span> <span class="o">*</span> <span class="n">l2</span><span class="p">)))</span>

            <span class="c1"># if the angle is greater than the half angle of the arc, remove</span>
            <span class="c1"># it from the arc</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="n">half_arc_angle</span><span class="p">:</span>
                <span class="n">arc</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">arc_ind_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># calculate arc direction angle, then rotate by 90 degrees</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">fx</span> <span class="o">-</span> <span class="n">ax</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fy</span> <span class="o">-</span> <span class="n">ay</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># draw lines to create arc with infinite radius</span>
        <span class="n">arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">make_line</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">arc_pos</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">ang</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="p">(</span><span class="n">diameter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">make_line</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">arc_pos</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="p">(</span><span class="n">ang</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">length</span><span class="o">=</span><span class="p">(</span><span class="n">diameter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">arc</span></div>


<div class="viewcode-block" id="make_pixel_map_point"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_pixel_map_point">[docs]</a><span class="k">def</span> <span class="nf">make_pixel_map_point</span><span class="p">(</span><span class="n">grid_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">centre_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a map of the distance of each pixel from a given centre position.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_size: The size of the grid, given as a 1D array with the number of pixels in each dimension.</span>
<span class="sd">        centre_pos: The position of the centre, given as a 1D array with the coordinates in each dimension.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A 2D array with the distance of each pixel from the given centre position.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `grid_size` and `centre_pos` do not have the same number of dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check for number of dimensions</span>
    <span class="n">num_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="c1"># check that centre_pos has the same dimensions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centre_pos</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The inputs centre_pos and grid_size must have the same number of dimensions.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># assign inputs and force to be integers</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">grid_size</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">centre_pos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># generate index vectors in each dimension</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># combine index matrices</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="n">pixel_map</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">pixel_map</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ny</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pixel_map</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">num_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="c1"># assign inputs and force to be integers</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span> <span class="o">=</span> <span class="n">grid_size</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">centre_pos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># generate index vectors in each dimension</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nz</span><span class="p">)</span> <span class="o">-</span> <span class="n">cz</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># combine index matrices</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">))</span>
        <span class="n">pixel_map</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">pixel_map</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ny</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">pixel_map</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pixel_map</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># throw error</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grid size must be 2 or 3D.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pixel_map</span></div>


<div class="viewcode-block" id="make_pixel_map_plane"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_pixel_map_plane">[docs]</a><span class="k">def</span> <span class="nf">make_pixel_map_plane</span><span class="p">(</span><span class="n">grid_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">normal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a pixel map of a plane with given normal vector and point.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_size: The size of the grid as a NumPy array [Nx, Ny, Nz].</span>
<span class="sd">        normal: The normal vector of the plane as a NumPy array [nx, ny, nz].</span>
<span class="sd">        point: A point on the plane as a NumPy array [px, py, pz].</span>

<span class="sd">    Returns:</span>
<span class="sd">        pixel_map: A 2D array with the distance of each pixel from the given plane.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the normal vector is zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># error checking</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">normal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Normal vector should not be zero.&#39;</span><span class="p">)</span>

    <span class="c1"># check for number of dimensions</span>
    <span class="n">num_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># assign inputs and force to be integers</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># create coordinate meshes</span>
        <span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
        <span class="p">[</span><span class="n">pointx</span><span class="p">,</span> <span class="n">pointy</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">[</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span> <span class="o">*</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># calculate distance according to Eq. (6) at</span>
        <span class="c1"># http://mathworld.wolfram.com/Point-PlaneDistance.html</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">px</span> <span class="o">-</span> <span class="n">pointx</span><span class="p">)</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="p">(</span><span class="n">py</span> <span class="o">-</span> <span class="n">pointy</span><span class="p">)</span> <span class="o">*</span> <span class="n">ny</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">normal</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">num_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="c1"># assign inputs and force to be integers</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># create coordinate meshes</span>
        <span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="n">pz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">pointx</span><span class="p">,</span> <span class="n">pointy</span><span class="p">,</span> <span class="n">pointz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nz</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                             <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nz</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                 <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

        <span class="c1"># calculate distance according to Eq. (6) at</span>
        <span class="c1"># http://mathworld.wolfram.com/Point-PlaneDistance.html</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">px</span> <span class="o">-</span> <span class="n">pointx</span><span class="p">)</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="p">(</span><span class="n">py</span> <span class="o">-</span> <span class="n">pointy</span><span class="p">)</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="p">(</span><span class="n">pz</span> <span class="o">-</span> <span class="n">pointz</span><span class="p">)</span> <span class="o">*</span> <span class="n">nz</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">normal</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># throw error</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grid size must be 2 or 3D.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pixel_map</span></div>


<div class="viewcode-block" id="make_bowl"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_bowl">[docs]</a><span class="k">def</span> <span class="nf">make_bowl</span><span class="p">(</span><span class="n">grid_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">bowl_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">diameter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
              <span class="n">focus_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">remove_overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a matrix representing a bowl-shaped object in 3D space.</span>

<span class="sd">    This function generates a 3D matrix representing a bowl-shaped object with the specified radius and diameter. The position</span>
<span class="sd">    of the bowl and the focus point can be specified, as well as whether to return a binary matrix or a matrix with</span>
<span class="sd">    continuous values. The optional parameter &#39;remove_overlap&#39; can be used to remove any overlap with the surrounding grid.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_size: size of the grid in each dimension</span>
<span class="sd">        bowl_pos: position of the bowl in the grid</span>
<span class="sd">        radius: radius of the bowl</span>
<span class="sd">        diameter: diameter of the bowl</span>
<span class="sd">        focus_pos: position of the focus point in the grid</span>
<span class="sd">        binary: whether to return a binary matrix</span>
<span class="sd">        remove_overlap: whether to remove overlap with the surrounding grid</span>

<span class="sd">    Returns:</span>
<span class="sd">        matrix: 3D matrix representing the bowl-shaped object</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if any of the input arguments are outside the valid range</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># =========================================================================</span>
    <span class="c1"># DEFINE LITERALS</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># threshold used to find the closest point to the radius</span>
    <span class="n">THRESHOLD</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="c1"># number of grid points to expand the bounding box compared to</span>
    <span class="c1"># sqrt(2)*diameter</span>
    <span class="n">BOUNDING_BOX_EXP</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># INPUT CHECKING</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># force integer input values</span>
    <span class="n">grid_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bowl_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">bowl_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">focus_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">focus_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">diameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>

    <span class="c1"># check the input ranges</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">grid_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The grid size must be positive.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bowl_pos</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bowl_pos</span> <span class="o">&gt;</span> <span class="n">grid_size</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The centre of the bowl must be within the grid.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The radius must be positive.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">diameter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The diameter must be positive.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">diameter</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The diameter of the bowl must be less than twice the radius of curvature.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">diameter</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The diameter must be an odd number of grid points.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">bowl_pos</span> <span class="o">==</span> <span class="n">focus_pos</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The focus_pos must be different to the bowl_pos.&#39;</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># BOUND THE GRID TO SPEED UP CALCULATION</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># create bounding box slightly larger than bowl diameter * sqrt(2)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">diameter</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="n">BOUNDING_BOX_EXP</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">Nz</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="n">grid_size_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">])</span>

    <span class="c1"># set the bowl position to be the centre of the bounding box</span>
    <span class="n">bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bowl_pos_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">bz</span><span class="p">])</span>

    <span class="c1"># set the focus position to be in the direction specified by the user</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">+</span> <span class="p">(</span><span class="n">focus_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="n">by</span> <span class="o">+</span> <span class="p">(</span><span class="n">focus_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">fz</span> <span class="o">=</span> <span class="n">bz</span> <span class="o">+</span> <span class="p">(</span><span class="n">focus_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">focus_pos_sm</span> <span class="o">=</span> <span class="p">[</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span><span class="p">]</span>

    <span class="c1"># preallocate storage variable</span>
    <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">))</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># CREATE DISTANCE MATRIX</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>

        <span class="c1"># find half the arc angle</span>
        <span class="n">half_arc_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">))</span>

        <span class="c1"># find centre of sphere on which the bowl lies</span>
        <span class="n">distance_cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">bx</span> <span class="o">-</span> <span class="n">fx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">by</span> <span class="o">-</span> <span class="n">fy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bz</span> <span class="o">-</span> <span class="n">fz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">radius</span> <span class="o">/</span> <span class="n">distance_cf</span> <span class="o">*</span> <span class="p">(</span><span class="n">fx</span> <span class="o">-</span> <span class="n">bx</span><span class="p">)</span> <span class="o">+</span> <span class="n">bx</span><span class="p">)</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">radius</span> <span class="o">/</span> <span class="n">distance_cf</span> <span class="o">*</span> <span class="p">(</span><span class="n">fy</span> <span class="o">-</span> <span class="n">by</span><span class="p">)</span> <span class="o">+</span> <span class="n">by</span><span class="p">)</span>
        <span class="n">cz</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">radius</span> <span class="o">/</span> <span class="n">distance_cf</span> <span class="o">*</span> <span class="p">(</span><span class="n">fz</span> <span class="o">-</span> <span class="n">bz</span><span class="p">)</span> <span class="o">+</span> <span class="n">bz</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span><span class="p">])</span>

        <span class="c1"># generate matrix with distance from the centre</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">make_pixel_map_point</span><span class="p">(</span><span class="n">grid_size_sm</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># set search radius to bowl radius</span>
        <span class="n">search_radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># generate matrix with distance from the centre</span>
        <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">make_pixel_map_plane</span><span class="p">(</span><span class="n">grid_size_sm</span><span class="p">,</span> <span class="n">bowl_pos_sm</span> <span class="o">-</span> <span class="n">focus_pos_sm</span><span class="p">,</span> <span class="n">bowl_pos_sm</span><span class="p">)</span>

        <span class="c1"># set search radius to 0 (the disc is flat)</span>
        <span class="n">search_radius</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># calculate distance from search radius</span>
    <span class="n">pixel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pixel_map</span> <span class="o">-</span> <span class="n">search_radius</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># DIMENSION 1</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># find the grid point that corresponds to the outside of the bowl in the</span>
    <span class="c1"># first dimension in both directions (the index gives the distance along</span>
    <span class="c1"># this dimension)</span>
    <span class="n">value_forw</span><span class="p">,</span> <span class="n">index_forw</span> <span class="o">=</span> <span class="n">pixel_map</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">pixel_map</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">value_back</span><span class="p">,</span> <span class="n">index_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pixel_map</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pixel_map</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># extract the linear index in the y-z plane of the values that lie on the</span>
    <span class="c1"># bowl surface</span>
    <span class="n">yz_ind_forw</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">value_forw</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span>
    <span class="n">yz_ind_back</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">value_back</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span>

    <span class="c1"># use these subscripts to extract the x-index of the grid points that lie</span>
    <span class="c1"># on the bowl surface</span>
    <span class="n">x_ind_forw</span> <span class="o">=</span> <span class="n">index_forw</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">yz_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">x_ind_back</span> <span class="o">=</span> <span class="n">index_back</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">yz_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># convert the linear index to equivalent subscript values</span>
    <span class="n">y_ind_forw</span><span class="p">,</span> <span class="n">z_ind_forw</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">yz_ind_forw</span><span class="p">)</span>
    <span class="n">y_ind_back</span><span class="p">,</span> <span class="n">z_ind_back</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">yz_ind_back</span><span class="p">)</span>

    <span class="c1"># combine x-y-z indices into a linear index</span>
    <span class="n">linear_index_forw</span> <span class="o">=</span> <span class="n">sub2ind</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">x_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">linear_index_back</span> <span class="o">=</span> <span class="n">sub2ind</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">Nx</span> <span class="o">-</span> <span class="n">x_ind_back</span><span class="p">,</span> <span class="n">y_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># assign these values to the bowl</span>
    <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">linear_index_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">linear_index_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># set existing bowl values to a distance of zero in the pixel map (this</span>
    <span class="c1"># avoids problems with overlapping pixels)</span>
    <span class="n">pixel_map</span><span class="p">[</span><span class="n">bowl_sm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># DIMENSION 2</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># find the grid point that corresponds to the outside of the bowl in the</span>
    <span class="c1"># second dimension in both directions (the pixel map is first re-ordered to</span>
    <span class="c1"># [X, Y, Z] -&gt; [Y, Z, X])</span>
    <span class="n">pixel_map_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">pixel_map</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">value_forw</span><span class="p">,</span> <span class="n">index_forw</span> <span class="o">=</span> <span class="n">pixel_map_temp</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">pixel_map_temp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">value_back</span><span class="p">,</span> <span class="n">index_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pixel_map_temp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pixel_map_temp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">pixel_map_temp</span>

    <span class="c1"># extract the linear index in the y-z plane of the values that lie on the</span>
    <span class="c1"># bowl surface</span>
    <span class="n">zx_ind_forw</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">value_forw</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span>
    <span class="n">zx_ind_back</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">value_back</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span>

    <span class="c1"># use these subscripts to extract the y-index of the grid points that lie</span>
    <span class="c1"># on the bowl surface</span>
    <span class="n">y_ind_forw</span> <span class="o">=</span> <span class="n">index_forw</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">zx_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">y_ind_back</span> <span class="o">=</span> <span class="n">index_back</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">zx_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># convert the linear index to equivalent subscript values</span>
    <span class="n">z_ind_forw</span><span class="p">,</span> <span class="n">x_ind_forw</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Nx</span><span class="p">],</span> <span class="n">zx_ind_forw</span><span class="p">)</span>
    <span class="n">z_ind_back</span><span class="p">,</span> <span class="n">x_ind_back</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Nx</span><span class="p">],</span> <span class="n">zx_ind_back</span><span class="p">)</span>

    <span class="c1"># combine x-y-z indices into a linear index</span>
    <span class="n">linear_index_forw</span> <span class="o">=</span> <span class="n">sub2ind</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">x_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">linear_index_back</span> <span class="o">=</span> <span class="n">sub2ind</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">x_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="n">y_ind_back</span><span class="p">,</span> <span class="n">z_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># assign these values to the bowl</span>
    <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">linear_index_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">linear_index_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># set existing bowl values to a distance of zero in the pixel map (this</span>
    <span class="c1"># avoids problems with overlapping pixels)</span>
    <span class="n">pixel_map</span><span class="p">[</span><span class="n">bowl_sm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># DIMENSION 3</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># find the grid point that corresponds to the outside of the bowl in the</span>
    <span class="c1"># third dimension in both directions (the pixel map is first re-ordered to</span>
    <span class="c1"># [X, Y, Z] -&gt; [Z, X, Y])</span>
    <span class="n">pixel_map_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">pixel_map</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">value_forw</span><span class="p">,</span> <span class="n">index_forw</span> <span class="o">=</span> <span class="n">pixel_map_temp</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">pixel_map_temp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">value_back</span><span class="p">,</span> <span class="n">index_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pixel_map_temp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pixel_map_temp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">pixel_map_temp</span>

    <span class="c1"># extract the linear index in the y-z plane of the values that lie on the</span>
    <span class="c1"># bowl surface</span>
    <span class="n">xy_ind_forw</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">value_forw</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span>
    <span class="n">xy_ind_back</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">value_back</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span>

    <span class="c1"># use these subscripts to extract the z-index of the grid points that lie</span>
    <span class="c1"># on the bowl surface</span>
    <span class="n">z_ind_forw</span> <span class="o">=</span> <span class="n">index_forw</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">xy_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">z_ind_back</span> <span class="o">=</span> <span class="n">index_back</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">xy_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># convert the linear index to equivalent subscript values</span>
    <span class="n">x_ind_forw</span><span class="p">,</span> <span class="n">y_ind_forw</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">],</span> <span class="n">xy_ind_forw</span><span class="p">)</span>
    <span class="n">x_ind_back</span><span class="p">,</span> <span class="n">y_ind_back</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">],</span> <span class="n">xy_ind_back</span><span class="p">)</span>

    <span class="c1"># combine x-y-z indices into a linear index</span>
    <span class="n">linear_index_forw</span> <span class="o">=</span> <span class="n">sub2ind</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">x_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_ind_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">linear_index_back</span> <span class="o">=</span> <span class="n">sub2ind</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">x_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_ind_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nz</span> <span class="o">-</span> <span class="n">z_ind_back</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># assign these values to the bowl</span>
    <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">linear_index_forw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">linear_index_back</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># RESTRICT SPHERE TO BOWL</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># remove grid points within the sphere that do not form part of the bowl</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>

        <span class="c1"># form vector from the geometric bowl centre to the back of the bowl</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">bowl_pos_sm</span> <span class="o">-</span> <span class="n">c</span>

        <span class="c1"># calculate length of vector</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">bowl_pos_sm</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># loop through the non-zero elements in the bowl matrix</span>
        <span class="n">bowl_ind</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">bowl_sm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bowl_ind_i</span> <span class="ow">in</span> <span class="n">bowl_ind</span><span class="p">:</span>

            <span class="c1"># extract the indices of the current point</span>
            <span class="n">x_ind</span><span class="p">,</span> <span class="n">y_ind</span><span class="p">,</span> <span class="n">z_ind</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">bowl_ind_i</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_ind</span><span class="p">,</span> <span class="n">y_ind</span><span class="p">,</span> <span class="n">z_ind</span><span class="p">])</span>

            <span class="c1"># form vector from the geometric bowl centre to the current point</span>
            <span class="c1"># on the bowl</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">c</span>

            <span class="c1"># calculate length of vector</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

            <span class="c1"># find the angle between the two vectors using the dot product,</span>
            <span class="c1"># normalised using the vector lengths</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">v1</span> <span class="o">*</span> <span class="n">v2</span> <span class="o">/</span> <span class="p">(</span><span class="n">l1</span> <span class="o">*</span> <span class="n">l2</span><span class="p">)))</span>

            <span class="c1">#         # alternative calculation normalised using radius of curvature</span>
            <span class="c1">#         theta2 = acos(sum( v1 .* v2 ./ radius**2 ))</span>

            <span class="c1"># if the angle is greater than the half angle of the bowl, remove</span>
            <span class="c1"># it from the bowl</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="n">half_arc_angle</span><span class="p">:</span>
                <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">matlab_assign</span><span class="p">(</span><span class="n">bowl_sm</span><span class="p">,</span> <span class="n">bowl_ind_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># form a distance map from the centre of the disc</span>
        <span class="n">pixelMapPoint</span> <span class="o">=</span> <span class="n">make_pixel_map_point</span><span class="p">(</span><span class="n">grid_size_sm</span><span class="p">,</span> <span class="n">bowl_pos_sm</span><span class="p">)</span>

        <span class="c1"># set all points in the disc greater than the diameter to zero</span>
        <span class="n">bowl_sm</span><span class="p">[</span><span class="n">pixelMapPoint</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># REMOVE OVERLAPPED POINTS</span>
    <span class="c1"># =========================================================================</span>

    <span class="k">if</span> <span class="n">remove_overlap</span><span class="p">:</span>

        <span class="c1"># define the shapes that capture the overlapped points, along with the</span>
        <span class="c1"># corresponding mask of which point to delete</span>
        <span class="n">overlap_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">overlap_delete</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">delete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">overlap_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>

        <span class="c1"># set loop flag</span>
        <span class="n">points_remaining</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># initialise deleted point counter</span>
        <span class="n">deleted_points</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># set list of possible permutations</span>
        <span class="n">perm_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">while</span> <span class="n">points_remaining</span><span class="p">:</span>

            <span class="c1"># get linear index of non-zero bowl elements</span>
            <span class="n">index_mat</span> <span class="o">=</span> <span class="n">matlab_find</span><span class="p">(</span><span class="n">bowl_sm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># set Boolean delete variable</span>
            <span class="n">delete_point</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># loop through all points on the bowl, and find the all the points with</span>
            <span class="c1"># more than 8 neighbours</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">index_mat_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_mat</span><span class="p">):</span>

                <span class="c1"># extract subscripts for current point</span>
                <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">],</span> <span class="n">index_mat_i</span><span class="p">)</span>

                <span class="c1"># ignore edge points</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cx</span> <span class="o">&lt;</span> <span class="n">Nx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cy</span> <span class="o">&lt;</span> <span class="n">Ny</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cz</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cz</span> <span class="o">&lt;</span> <span class="n">Nz</span><span class="p">):</span>

                    <span class="c1"># extract local region around current point</span>
                    <span class="n">region</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[</span><span class="n">cx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># FARID might not work</span>

                    <span class="c1"># if there&#39;s more than 8 neighbours, check the point for</span>
                    <span class="c1"># deletion</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>

                        <span class="c1"># loop through the different shapes</span>
                        <span class="k">for</span> <span class="n">shape_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">overlap_shapes</span><span class="p">)):</span>

                            <span class="c1"># check every permutation of the shape, and apply the</span>
                            <span class="c1"># deletion mask if the pattern matches</span>

                            <span class="c1"># loop through possible shape permutations</span>
                            <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm_list</span><span class="p">)):</span>

                                <span class="c1"># get shape and delete mask</span>
                                <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">overlap_shapes</span><span class="p">[</span><span class="n">shape_index</span><span class="p">]</span>
                                <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">overlap_delete</span><span class="p">[</span><span class="n">shape_index</span><span class="p">]</span>

                                <span class="c1"># permute</span>
                                <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">perm_list</span><span class="p">[</span><span class="n">ind1</span><span class="p">])</span>
                                <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">perm_list</span><span class="p">[</span><span class="n">ind1</span><span class="p">])</span>

                                <span class="c1"># loop through possible shape reflections</span>
                                <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>

                                    <span class="c1"># flipfunc the shape</span>
                                    <span class="k">if</span> <span class="n">ind2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                    <span class="k">elif</span> <span class="n">ind2</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="k">elif</span> <span class="n">ind2</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                    <span class="k">elif</span> <span class="n">ind2</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="k">elif</span> <span class="n">ind2</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                    <span class="k">elif</span> <span class="n">ind2</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                                    <span class="c1"># rotate the shape 4 x 90 degrees</span>
                                    <span class="k">for</span> <span class="n">ind3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>

                                        <span class="c1"># check if the shape matches</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">overlap_s</span> <span class="o">==</span> <span class="n">region</span><span class="p">):</span>
                                            <span class="n">delete_point</span> <span class="o">=</span> <span class="kc">True</span>

                                        <span class="c1"># break from loop if a match is found</span>
                                        <span class="k">if</span> <span class="n">delete_point</span><span class="p">:</span>
                                            <span class="k">break</span>

                                        <span class="c1"># rotate shape</span>
                                        <span class="n">overlap_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">overlap_s</span><span class="p">)</span>
                                        <span class="n">overlap_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">overlap_d</span><span class="p">)</span>

                                    <span class="c1"># break from loop if a match is found</span>
                                    <span class="k">if</span> <span class="n">delete_point</span><span class="p">:</span>
                                        <span class="k">break</span>

                                <span class="c1"># break from loop if a match is found</span>
                                <span class="k">if</span> <span class="n">delete_point</span><span class="p">:</span>
                                    <span class="k">break</span>

                            <span class="c1"># remove point from bowl if required, and update</span>
                            <span class="c1"># counter</span>
                            <span class="k">if</span> <span class="n">delete_point</span><span class="p">:</span>
                                <span class="n">bowl_sm</span><span class="p">[</span><span class="n">cx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[</span><span class="n">cx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                                                       <span class="n">cy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                                                       <span class="n">cz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">cz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span>
                                    <span class="n">overlap_d</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># Farid won&#39;t work probably</span>
                                <span class="n">deleted_points</span> <span class="o">=</span> <span class="n">deleted_points</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="k">break</span>

                <span class="c1"># break from loop if a match is found</span>
                <span class="k">if</span> <span class="n">delete_point</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># break from while loop if the outer for loop has completed</span>
            <span class="c1"># without deleting a point</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_mat</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">points_remaining</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># display status</span>
        <span class="k">if</span> <span class="n">deleted_points</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{deleted_points}</span><span class="s1"> overlapped points removed from bowl&#39;</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># PLACE BOWL WITHIN LARGER GRID</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># preallocate storage variable</span>
    <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
        <span class="n">bowl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bowl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="c1"># calculate position of bounding box within larger grid</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bx</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">Nx</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">by</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">Ny</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bz</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">z1</span> <span class="o">+</span> <span class="n">Nz</span>

    <span class="c1"># truncate bounding box if it falls outside the grid</span>
    <span class="k">if</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">):,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">y1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[:,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span><span class="p">):,</span> <span class="p">:]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">z1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[:,</span> <span class="p">:,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z1</span><span class="p">):]</span>
        <span class="n">z1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;=</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[:</span><span class="o">-</span><span class="n">to_delete</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">y2</span> <span class="o">&gt;=</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">to_delete</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z2</span> <span class="o">&gt;=</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="n">z2</span> <span class="o">-</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">bowl_sm</span> <span class="o">=</span> <span class="n">bowl_sm</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="n">to_delete</span><span class="p">]</span>
        <span class="n">z2</span> <span class="o">=</span> <span class="n">grid_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># place bowl into grid</span>
    <span class="n">bowl</span><span class="p">[</span><span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bowl_sm</span>

    <span class="k">return</span> <span class="n">bowl</span></div>


<div class="viewcode-block" id="make_multi_bowl"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_multi_bowl">[docs]</a><span class="k">def</span> <span class="nf">make_multi_bowl</span><span class="p">(</span><span class="n">grid_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bowl_pos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">diameter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                    <span class="n">focus_pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">remove_overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a multi-bowl mask for an image given the size of the grid, the positions of the bowls, the radius of each bowl, the diameter of the bowls, and the position of the focus.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_size: The size of the grid (assumed to be square).</span>
<span class="sd">        bowl_pos: A list of tuples containing the (x, y) coordinates of the center of each bowl.</span>
<span class="sd">        radius: The radius of each bowl.</span>
<span class="sd">        diameter: The diameter of the bowls.</span>
<span class="sd">        focus_pos: The (x, y) coordinates of the focus.</span>
<span class="sd">        binary: Whether to return a binary mask (default: False).</span>
<span class="sd">        remove_overlap: Whether to remove overlap between the bowls (default: False).</span>

<span class="sd">    Returns:</span>
<span class="sd">        bowls:</span>
<span class="sd">        bowls_labeled:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">if</span> <span class="n">bowl_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bowl_pos should contain 3 columns, with [bx, by, bz] in each row.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bowl_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of rows in bowl_pos and radius does not match.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bowl_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of rows in bowl_pos and diameter does not match.&#39;</span><span class="p">)</span>

    <span class="c1"># force integer grid size values</span>
    <span class="n">grid_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bowl_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">bowl_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">focus_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">focus_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">diameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># CREATE BOWLS</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># preallocate output matrices</span>
    <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
        <span class="n">bowls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bowls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="n">bowls_labelled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="c1"># loop for calling make_bowl</span>
    <span class="k">for</span> <span class="n">bowl_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bowl_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="c1"># update command line status</span>
        <span class="k">if</span> <span class="n">bowl_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">TicToc</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">TicToc</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Creating bowl </span><span class="si">{</span><span class="n">bowl_index</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">bowl_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> ... &#39;</span><span class="p">)</span>

        <span class="c1"># get parameters for current bowl</span>
        <span class="k">if</span> <span class="n">bowl_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bowl_pos_k</span> <span class="o">=</span> <span class="n">bowl_pos</span><span class="p">[</span><span class="n">bowl_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bowl_pos_k</span> <span class="o">=</span> <span class="n">bowl_pos</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">radius_k</span> <span class="o">=</span> <span class="n">radius</span><span class="p">[</span><span class="n">bowl_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radius_k</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">diameter_k</span> <span class="o">=</span> <span class="n">diameter</span><span class="p">[</span><span class="n">bowl_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter_k</span> <span class="o">=</span> <span class="n">diameter</span>

        <span class="k">if</span> <span class="n">focus_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">focus_pos_k</span> <span class="o">=</span> <span class="n">focus_pos</span><span class="p">[</span><span class="n">bowl_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">focus_pos_k</span> <span class="o">=</span> <span class="n">focus_pos</span>

        <span class="c1"># create new bowl</span>
        <span class="n">new_bowl</span> <span class="o">=</span> <span class="n">make_bowl</span><span class="p">(</span>
            <span class="n">grid_size</span><span class="p">,</span> <span class="n">bowl_pos_k</span><span class="p">,</span> <span class="n">radius_k</span><span class="p">,</span> <span class="n">diameter_k</span><span class="p">,</span> <span class="n">focus_pos_k</span><span class="p">,</span>
            <span class="n">remove_overlap</span><span class="o">=</span><span class="n">remove_overlap</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="n">binary</span>
        <span class="p">)</span>

        <span class="c1"># add bowl to bowl matrix</span>
        <span class="n">bowls</span> <span class="o">=</span> <span class="n">bowls</span> <span class="o">+</span> <span class="n">new_bowl</span>

        <span class="c1"># add new bowl to labelling matrix</span>
        <span class="n">bowls_labelled</span><span class="p">[</span><span class="n">new_bowl</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bowl_index</span>

    <span class="n">TicToc</span><span class="o">.</span><span class="n">toc</span><span class="p">()</span>

    <span class="c1"># check if any of the bowls are overlapping</span>
    <span class="n">max_nd_val</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">max_nd</span><span class="p">(</span><span class="n">bowls</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_nd_val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># display warning</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: </span><span class="si">{</span><span class="n">max_nd_val</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> bowls are overlapping&#39;</span><span class="p">)</span>

        <span class="c1"># force the output to be binary</span>
        <span class="n">bowls</span><span class="p">[</span><span class="n">bowls</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">bowls</span><span class="p">,</span> <span class="n">bowls_labelled</span></div>


<div class="viewcode-block" id="make_multi_arc"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_multi_arc">[docs]</a><span class="k">def</span> <span class="nf">make_multi_arc</span><span class="p">(</span><span class="n">grid_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">arc_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                   <span class="n">diameter</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">focus_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a multi-arc mask for an image given the size of the grid, the positions and properties of the arcs, and the position of the focus.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_size: The size of the grid (assumed to be square).</span>
<span class="sd">        arc_pos: An array containing the (x, y) coordinates of the center of each arc.</span>
<span class="sd">        radius: The radius of each arc. Can be a single value or an array with one value for each arc.</span>
<span class="sd">        diameter: The diameter of the arcs. Can be a single value or an array with one value for each arc.</span>
<span class="sd">        focus_pos: The (x, y) coordinates of the focus.</span>

<span class="sd">    Returns:</span>
<span class="sd">        arcs: A binary mask of the arcs.</span>
<span class="sd">        arcs_labelled: A labelled mask of the arcs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the shape of arc_pos is not (N, 2), if the number of rows in arc_pos and radius do not match, or if the number of rows in arc_pos and diameter do not match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check inputs</span>
    <span class="k">if</span> <span class="n">arc_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;arc_pos should contain 2 columns, with [ax, ay] in each row.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arc_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of rows in arc_pos and radius does not match.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arc_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of rows in arc_pos and diameter does not match.&#39;</span><span class="p">)</span>

    <span class="c1"># force integer grid size values</span>
    <span class="n">grid_size</span> <span class="o">=</span> <span class="n">grid_size</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">arc_pos</span> <span class="o">=</span> <span class="n">arc_pos</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
    <span class="n">focus_pos</span> <span class="o">=</span> <span class="n">focus_pos</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># CREATE ARCS</span>
    <span class="c1"># =========================================================================</span>

    <span class="c1"># create empty matrix</span>
    <span class="n">arcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>
    <span class="n">arcs_labelled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="c1"># loop for calling make_arc</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arc_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="c1"># get parameters for current arc</span>
        <span class="k">if</span> <span class="n">arc_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arc_pos_k</span> <span class="o">=</span> <span class="n">arc_pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arc_pos_k</span> <span class="o">=</span> <span class="n">arc_pos</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">radius_k</span> <span class="o">=</span> <span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radius_k</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">diameter_k</span> <span class="o">=</span> <span class="n">diameter</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter_k</span> <span class="o">=</span> <span class="n">diameter</span>

        <span class="k">if</span> <span class="n">focus_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">focus_pos_k</span> <span class="o">=</span> <span class="n">focus_pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">focus_pos_k</span> <span class="o">=</span> <span class="n">focus_pos</span>

        <span class="c1"># create new arc</span>
        <span class="n">new_arc</span> <span class="o">=</span> <span class="n">make_arc</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">arc_pos_k</span><span class="p">,</span> <span class="n">radius_k</span><span class="p">,</span> <span class="n">diameter_k</span><span class="p">,</span> <span class="n">focus_pos_k</span><span class="p">)</span>

        <span class="c1"># add arc to arc matrix</span>
        <span class="n">arcs</span> <span class="o">=</span> <span class="n">arcs</span> <span class="o">+</span> <span class="n">new_arc</span>

        <span class="c1"># add new arc to labelling matrix</span>
        <span class="n">arcs_labelled</span><span class="p">[</span><span class="n">new_arc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

    <span class="c1"># check if any of the arcs are overlapping</span>
    <span class="n">max_nd_val</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">max_nd</span><span class="p">(</span><span class="n">arcs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_nd_val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># display warning</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: </span><span class="si">{</span><span class="n">max_nd_val</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> arcs are overlapping&#39;</span><span class="p">)</span>

        <span class="c1"># force the output to be binary</span>
        <span class="n">arcs</span><span class="p">[</span><span class="n">arcs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">arcs</span><span class="p">,</span> <span class="n">arcs_labelled</span></div>


<div class="viewcode-block" id="make_sphere"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_sphere">[docs]</a><span class="k">def</span> <span class="nf">make_sphere</span><span class="p">(</span><span class="n">Nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Ny</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Nz</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">plot_sphere</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a sphere mask for a 3D grid given the dimensions of the grid, the radius of the sphere, and optional flags to plot the sphere and/or return a binary mask.</span>

<span class="sd">    Args:</span>
<span class="sd">        Nx: The number of grid points in the x-dimension.</span>
<span class="sd">        Ny: The number of grid points in the y-dimension.</span>
<span class="sd">        Nz: The number of grid points in the z-dimension.</span>
<span class="sd">        radius: The radius of the sphere.</span>
<span class="sd">        plot_sphere: Whether to plot the sphere (default: False).</span>
<span class="sd">        binary: Whether to return a binary mask (default: False).</span>

<span class="sd">    Returns:</span>
<span class="sd">        sphere: The sphere mask as a NumPy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># enforce a centered sphere</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">Nx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">Ny</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">cz</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">Nz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># preallocate the storage variable</span>
    <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
        <span class="n">sphere</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sphere</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">))</span>

    <span class="c1"># create a guide circle from which the individal radii can be extracted</span>
    <span class="n">guide_circle</span> <span class="o">=</span> <span class="n">make_circle</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>

    <span class="c1"># step through the guide circle points and create partially filled discs</span>
    <span class="n">centerpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">reflection_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centerpoints</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">centerpoint_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centerpoints</span><span class="p">)):</span>

        <span class="c1"># extract the current row from the guide circle</span>
        <span class="n">row_data</span> <span class="o">=</span> <span class="n">guide_circle</span><span class="p">[:,</span> <span class="n">centerpoints</span><span class="p">[</span><span class="n">centerpoint_index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># add an index to the grid points in the current row</span>
        <span class="n">row_index</span> <span class="o">=</span> <span class="n">row_data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># calculate the radius</span>
        <span class="n">swept_radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_index</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">row_index</span><span class="p">[</span><span class="n">row_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># create a circle to add to the sphere</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">make_circle</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span><span class="p">,</span> <span class="n">swept_radius</span><span class="p">)</span>

        <span class="c1"># make an empty fill matrix</span>
        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="n">circle_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">circle_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">))</span>

        <span class="c1"># fill in the circle line by line</span>
        <span class="n">fill_centerpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cz</span> <span class="o">-</span> <span class="n">swept_radius</span><span class="p">,</span> <span class="n">cz</span> <span class="o">+</span> <span class="n">swept_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fill_centerpoints_i</span> <span class="ow">in</span> <span class="n">fill_centerpoints</span><span class="p">:</span>

            <span class="c1"># extract the first row</span>
            <span class="n">row_data</span> <span class="o">=</span> <span class="n">circle</span><span class="p">[:,</span> <span class="n">fill_centerpoints_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># add an index to the grid points in the current row</span>
            <span class="n">row_index</span> <span class="o">=</span> <span class="n">row_data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># calculate the diameter</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">row_index</span><span class="p">[</span><span class="n">row_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">stop_index</span> <span class="o">=</span> <span class="n">row_index</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># count how many points on the line</span>
            <span class="n">num_points</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>

            <span class="c1"># fill in the line</span>
            <span class="k">if</span> <span class="n">start_index</span> <span class="o">!=</span> <span class="n">stop_index</span> <span class="ow">and</span> <span class="p">(</span><span class="n">stop_index</span> <span class="o">-</span> <span class="n">start_index</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_points</span><span class="p">:</span>
                <span class="n">circle_fill</span><span class="p">[(</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">num_points</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">stop_index</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_points</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
                <span class="n">fill_centerpoints_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># remove points from the filled circle that existed in the previous</span>
        <span class="c1"># layer</span>
        <span class="k">if</span> <span class="n">centerpoint_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sphere</span><span class="p">[</span><span class="n">centerpoints</span><span class="p">[</span><span class="n">centerpoint_index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">circle</span> <span class="o">+</span> <span class="n">circle_fill</span>
            <span class="n">prev_circle</span> <span class="o">=</span> <span class="n">circle</span> <span class="o">+</span> <span class="n">circle_fill</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev_circle_alt</span> <span class="o">=</span> <span class="n">circle</span> <span class="o">+</span> <span class="n">circle_fill</span>
            <span class="n">circle_fill</span> <span class="o">=</span> <span class="n">circle_fill</span> <span class="o">-</span> <span class="n">prev_circle</span>
            <span class="n">circle_fill</span><span class="p">[</span><span class="n">circle_fill</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sphere</span><span class="p">[</span><span class="n">centerpoints</span><span class="p">[</span><span class="n">centerpoint_index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">circle</span> <span class="o">+</span> <span class="n">circle_fill</span>
            <span class="n">prev_circle</span> <span class="o">=</span> <span class="n">prev_circle_alt</span>

        <span class="c1"># create the other half of the sphere at the same time</span>
        <span class="k">if</span> <span class="n">centerpoint_index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centerpoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sphere</span><span class="p">[</span><span class="n">cx</span> <span class="o">+</span> <span class="n">reflection_offset</span><span class="p">[</span><span class="n">centerpoint_index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">[</span><span class="n">centerpoints</span><span class="p">[</span><span class="n">centerpoint_index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span>
                                                                          <span class="p">:]</span>

    <span class="c1"># plot results</span>
    <span class="k">if</span> <span class="n">plot_sphere</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="n">sphere</span></div>


<div class="viewcode-block" id="make_spherical_section"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.make_spherical_section">[docs]</a><span class="k">def</span> <span class="nf">make_spherical_section</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_section</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a spherical section mask given the radius and height of the section and optional parameters to specify the width and/or plot and return a binary mask.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius: The radius of the spherical section.</span>
<span class="sd">        height: The height of the spherical section.</span>
<span class="sd">        width: The width of the spherical section (default: height).</span>
<span class="sd">        plot_section: Whether to plot the spherical section (default: False).</span>
<span class="sd">        binary: Whether to return a binary mask (default: False).</span>

<span class="sd">    Returns:</span>
<span class="sd">        ss: The spherical section mask as a NumPy array.</span>
<span class="sd">        dist_map: The distance map of the spherical section mask as a NumPy array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the width is not an odd number.</span>
<span class="sd">        NotImplementedError: Plotting not currently supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_spherical_sections</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># force inputs to be integers</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>

    <span class="n">use_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_width</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input width must be an odd number.&#39;</span><span class="p">)</span>

    <span class="c1"># calculate minimum grid dimensions to fit entire sphere</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># create sphere</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">make_sphere</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">binary</span><span class="p">)</span>

    <span class="c1"># truncate to given height</span>
    <span class="k">if</span> <span class="n">use_spherical_sections</span><span class="p">:</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[:</span><span class="n">height</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ss</span><span class="p">[:,</span> <span class="p">:</span><span class="n">height</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># flatten transducer and store the maximum and indices</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># calculate the total length/width of the transducer</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">mx</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># truncate transducer grid based on length (removes empty rows and columns)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="n">length</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[:,</span> <span class="n">offset</span><span class="p">:</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="o">-</span><span class="n">offset</span><span class="p">]</span>

    <span class="c1"># also truncate to given width if defined by user</span>
    <span class="k">if</span> <span class="n">use_width</span><span class="p">:</span>

        <span class="c1"># check the value is appropriate</span>
        <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input for width must be less than or equal to transducer length.&#39;</span><span class="p">)</span>

        <span class="c1"># calculate offset</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">length</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># truncate transducer grid</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[:,</span> <span class="n">offset</span><span class="p">:</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># compute average distance between each grid point and its contiguous</span>

    <span class="c1"># calculate x-index of each grid point in the spherical section, create</span>
    <span class="c1"># mask and remove singleton dimensions</span>
    <span class="n">mx</span><span class="p">,</span> <span class="n">mx_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">ss</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mx_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mx_ind</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask</span>

    <span class="c1"># double check there there is only one value of spherical section in</span>
    <span class="c1"># each matrix column</span>
    <span class="k">if</span> <span class="n">mx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ss</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;mean neighbour distance cannot be calculated uniquely due to overlapping points in the x-direction&#39;</span><span class="p">)</span>

    <span class="c1"># calculate average distance to grid point neighbours in the flat case</span>
    <span class="n">x_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">y_dist</span> <span class="o">=</span> <span class="n">x_dist</span><span class="o">.</span><span class="n">T</span>
    <span class="n">flat_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x_dist</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y_dist</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">flat_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flat_dist</span><span class="p">)</span>

    <span class="c1"># compute distance map</span>
    <span class="n">dist_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mx_ind</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>

            <span class="c1"># clear map</span>
            <span class="n">local_heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="c1"># extract the height (x-distance) of the 8 neighbouring grid</span>
            <span class="c1"># points</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">local_heights</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">local_heights</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">local_heights</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">local_heights</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">local_heights</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">local_heights</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">local_heights</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">local_heights</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_heights</span> <span class="o">=</span> <span class="n">mx_ind</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>

            <span class="c1"># compute average variation from center</span>
            <span class="n">local_heights_var</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">local_heights</span> <span class="o">-</span> <span class="n">local_heights</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># threshold no neighbours</span>
            <span class="n">local_heights_var</span><span class="p">[</span><span class="n">local_heights</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># calculate total distance from centre</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x_dist</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y_dist</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">local_heights_var</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># average and store as a ratio</span>
            <span class="n">dist_map</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">-</span> <span class="n">flat_dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">flat_dist</span>

    <span class="c1"># threshold out the non-transducer grid points</span>
    <span class="n">dist_map</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># plot if required</span>
    <span class="k">if</span> <span class="n">plot_section</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">return</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dist_map</span></div>


<div class="viewcode-block" id="focused_bowl_oneil"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.focused_bowl_oneil">[docs]</a><span class="k">def</span> <span class="nf">focused_bowl_oneil</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">diameter</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">velocity</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">frequency</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sound_speed</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                       <span class="n">density</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">axial_positions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">lateral_positions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates O&#39;Neil&#39;s solution for the axial and lateral pressure amplitude generated by a focused bowl transducer.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius: The radius of the transducer.</span>
<span class="sd">        diameter: The diameter of the transducer.</span>
<span class="sd">        velocity: The normal surface velocity of the transducer.</span>
<span class="sd">        frequency: The driving frequency of the sinusoid.</span>
<span class="sd">        sound_speed: The sound speed in the medium.</span>
<span class="sd">        density: The density of the medium.</span>
<span class="sd">        axial_positions: The positions along the beam axis where the pressure is evaluated (0 corresponds to the transducer surface). Set to [] to return only lateral pressure.</span>
<span class="sd">        lateral_positions: The lateral positions through the geometric focus where the pressure is evaluated (0 corresponds to the beam axis). Set to [] to return only axial pressure.</span>

<span class="sd">    Returns:</span>
<span class="sd">       p-axial: The axial pressure amplitude.</span>
<span class="sd">       p-lateral: The lateral pressure amplitude.</span>

<span class="sd">    Example:</span>
<span class="sd">        # define transducer parameters</span>
<span class="sd">        radius = 140e-3  # [m]</span>
<span class="sd">        diameter = 120e-3  # [m]</span>
<span class="sd">        velocity = 100e-3  # [m / s]</span>
<span class="sd">        frequency = 1e6  # [Hz]</span>
<span class="sd">        sound_speed = 1500  # [m / s]</span>
<span class="sd">        density = 1000  # [kg / m ^ 3]</span>

<span class="sd">        # define position vectors</span>
<span class="sd">        axial_position = np.arange(0, 250e-3 + 1e-4, 1e-4)  # [m]</span>
<span class="sd">        lateral_position = np.arange(-15e-3, 15e-3 + 1e-4, 1e-4)  # [m]</span>

<span class="sd">        # evaluate pressure</span>
<span class="sd">        [p_axial, p_lateral] = focused_bowl_oneil(radius, diameter,</span>
<span class="sd">                                                  velocity, frequency, sound_speed, density,</span>
<span class="sd">                                                  axial_position, lateral_position)</span>

<span class="sd">    References:</span>
<span class="sd">        O&#39;Neil, H. (1949). Theory of focusing radiators. J. Acoust. Soc. Am., 21(5), 516-526.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">float_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="k">def</span> <span class="nf">calculate_axial_pressure</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># calculate distances</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">axial_positions</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">axial_positions</span>
        <span class="n">E</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axial_positions</span> <span class="o">/</span> <span class="n">radius</span><span class="p">)</span>

        <span class="c1"># compute pressure</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">E</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># replace values where axial_position is equal to the radius with limit</span>
        <span class="n">P</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">axial_positions</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">float_eps</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">h</span>

        <span class="c1"># calculate magnitude of the on - axis pressure</span>
        <span class="n">axial_pressure</span> <span class="o">=</span> <span class="n">density</span> <span class="o">*</span> <span class="n">sound_speed</span> <span class="o">*</span> <span class="n">velocity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axial_pressure</span>

    <span class="k">def</span> <span class="nf">calculate_lateral_pressure</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># calculate magnitude of the lateral pressure at the geometric focus</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">lateral_positions</span> <span class="o">*</span> <span class="n">diameter</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">lateral_pressure</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">density</span> <span class="o">*</span> <span class="n">sound_speed</span> <span class="o">*</span> <span class="n">velocity</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">jv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span> <span class="o">/</span> <span class="n">Z</span>

        <span class="c1"># replace origin with limit</span>
        <span class="n">lateral_pressure</span><span class="p">[</span><span class="n">lateral_positions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span> <span class="o">*</span> <span class="n">sound_speed</span> <span class="o">*</span> <span class="n">velocity</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">h</span>
        <span class="k">return</span> <span class="n">lateral_pressure</span>

    <span class="c1"># wave number</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">frequency</span> <span class="o">/</span> <span class="n">sound_speed</span>

    <span class="c1"># height of rim</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">p_axial</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">p_lateral</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">lateral_positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_lateral</span> <span class="o">=</span> <span class="n">calculate_lateral_pressure</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">axial_positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_axial</span> <span class="o">=</span> <span class="n">calculate_axial_pressure</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">p_axial</span><span class="p">,</span> <span class="n">p_lateral</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">p_axial</span><span class="p">,</span> <span class="n">p_lateral</span><span class="p">]</span></div>


<div class="viewcode-block" id="ndgrid"><a class="viewcode-back" href="../../../kwave.utils.mapgen.html#kwave.utils.mapgen.ndgrid">[docs]</a><span class="k">def</span> <span class="nf">ndgrid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Walter Simson, Farid Yagubbayli
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    </body>
</html>