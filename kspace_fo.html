<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kSpace First Order &mdash; kWave-py  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/sphinx-toolbox-code.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="kWaveSimulation" href="ksimulation.html" />
    <link rel="prev" title="kSource" href="ksource.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> kWave-py
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="get_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_started/first_steps.html">First Steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_started/contrib.html">Contribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_started/license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Base Modules</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="kgrid.html">kWaveGrid</a></li>
<li class="toctree-l1"><a class="reference internal" href="kmedium.html">kMedium</a></li>
<li class="toctree-l1"><a class="reference internal" href="ksensor.html">kSensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="ksource.html">kSource</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">kSpace First Order</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-kwave.kspaceFirstOrder">Decorator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kwave.kspaceFirstOrder2D">kSpaceFirstOrder 2D</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kwave.kspaceFirstOrder3D">kSpaceFirstOrder 3D</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-kwave.kspaceFirstOrderAS">kSpaceFirstOrder Axisymmetric</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ksimulation.html">kWaveSimulation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Helper Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="simopt.html">Simulation Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="recorder.html">Recorder</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">kWave-py</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>kSpace First Order</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/kspace_fo.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="kspace-first-order">
<h1>kSpace First Order<a class="headerlink" href="#kspace-first-order" title="Permalink to this headline"></a></h1>
<div class="section" id="module-kwave.kspaceFirstOrder">
<span id="decorator"></span><h2>Decorator<a class="headerlink" href="#module-kwave.kspaceFirstOrder" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder.kspaceFirstOrderC">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrderC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder.kspaceFirstOrderC" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Decorator for the kspaceFO-CPU functions</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func</strong> – kspaceFirstOrderNDC function where 1 &lt;= N &lt;= 3</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Function wrapper</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder.kspaceFirstOrderG">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrderG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder.kspaceFirstOrderG" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Decorator for the kspaceFO-GPU functions</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func</strong> – kspaceFirstOrderNDG function where 1 &lt;= N &lt;= 3</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Function wrapper</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-kwave.kspaceFirstOrder2D">
<span id="kspacefirstorder-2d"></span><h2>kSpaceFirstOrder 2D<a class="headerlink" href="#module-kwave.kspaceFirstOrder2D" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder2D.kspaceFirstOrder2D">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder2D.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrder2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kgrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">medium</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder2D.kspaceFirstOrder2D" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>2D time-domain simulation of wave propagation.</p>
<p>kspaceFirstOrder2D simulates the time-domain propagation of
compressional waves through a two-dimensional homogeneous or
heterogeneous acoustic medium given four input structures: kgrid,
medium, source, and sensor. The computation is based on a first-order
k-space model which accounts for power law absorption and a
heterogeneous sound speed and density. If medium.BonA is specified,
cumulative nonlinear effects are also modelled. At each time-step
(defined by kgrid.dt and kgrid.Nt or kgrid.t_array), the acoustic
field parameters at the positions defined by sensor.mask are recorded
and stored. If kgrid.t_array is set to ‘auto’, this array is
automatically generated using the makeTime method of the kWaveGrid
class. An anisotropic absorbing boundary layer called a perfectly
matched layer (PML) is implemented to prevent waves that leave one
side of the domain being reintroduced from the opposite side (a
consequence of using the FFT to compute the spatial derivatives in
the wave equation). This allows infinite domain simulations to be
computed using small computational grids.</p>
<p>For a homogeneous medium the formulation is exact and the time-steps
are only limited by the effectiveness of the perfectly matched layer.
For a heterogeneous medium, the solution represents a leap-frog
pseudospectral method with a k-space correction that improves the
accuracy of computing the temporal derivatives. This allows larger
time-steps to be taken for the same level of accuracy compared to
conventional pseudospectral time-domain methods. The computational
grids are staggered both spatially and temporally.</p>
<p>An initial pressure distribution can be specified by assigning a
matrix (the same size as the computational grid) of arbitrary numeric
values to source.p0. A time varying pressure source can similarly be
specified by assigning a binary matrix (i.e., a matrix of 1’s and 0’s
with the same dimensions as the computational grid) to source.p_mask
where the 1’s represent the grid points that form part of the source.
The time varying input signals are then assigned to source.p. This
can be a single time series (in which case it is applied to all
source elements), or a matrix of time series following the source
elements using MATLAB’s standard column-wise linear matrix index
ordering. A time varying velocity source can be specified in an
analogous fashion, where the source location is specified by
source.u_mask, and the time varying input velocity is assigned to
source.ux and source.uy.</p>
<p>The field values are returned as arrays of time series at the sensor
locations defined by sensor.mask. This can be defined in three
different ways. (1) As a binary matrix (i.e., a matrix of 1’s and 0’s
with the same dimensions as the computational grid) representing the
grid points within the computational grid that will collect the data.
(2) As the grid coordinates of two opposing corners of a rectangle in
the form [x1; y1; x2; y2]. This is equivalent to using a binary
sensor mask covering the same region, however, the output is indexed
differently as discussed below. (3) As a series of Cartesian
coordinates within the grid which specify the location of the
pressure values stored at each time step. If the Cartesian
coordinates don’t exactly match the coordinates of a grid point, the
output values are calculated via interpolation. The Cartesian points
must be given as a 2 by N matrix corresponding to the x and y
positions, respectively, where the Cartesian origin is assumed to be
in the center of the grid. If no output is required, the sensor input
can be replaced with an empty array [].</p>
<p>If sensor.mask is given as a set of Cartesian coordinates, the
computed sensor_data is returned in the same order. If sensor.mask is
given as a binary matrix, sensor_data is returned using MATLAB’s
standard column-wise linear matrix index ordering. In both cases, the
recorded data is indexed as sensor_data(sensor_point_index,
time_index). For a binary sensor mask, the field values at a
particular time can be restored to the sensor positions within the
computation grid using unmaskSensorData. If sensor.mask is given as a
list of opposing corners of a rectangle, the recorded data is indexed
as sensor_data(rect_index).p(x_index, y_index, time_index), where
x_index and y_index correspond to the grid index within the
rectangle, and rect_index corresponds to the number of rectangles if
more than one is specified.</p>
<p>By default, the recorded acoustic pressure field is passed directly
to the output sensor_data. However, other acoustic parameters can
also be recorded by setting sensor.record to a cell array of the form
{‘p’, ‘u’, ‘p_max’, …}. For example, both the particle velocity and
the acoustic pressure can be returned by setting sensor.record =
{‘p’, ‘u’}. If sensor.record is given, the output sensor_data is
returned as a structure with the different outputs appended as
structure fields. For example, if sensor.record = {‘p’, ‘p_final’,
‘p_max’, ‘u’}, the output would contain fields sensor_data.p,
sensor_data.p_final, sensor_data.p_max, sensor_data.ux, and
sensor_data.uy. Most of the output parameters are recorded at the
given sensor positions and are indexed as
sensor_data.field(sensor_point_index, time_index) or
sensor_data(rect_index).field(x_index, y_index, time_index) if using
a sensor mask defined as opposing rectangular corners. The exceptions
are the averaged quantities (‘p_max’, ‘p_rms’, ‘u_max’, ‘p_rms’,
‘I_avg’), the ‘all’ quantities (‘p_max_all’, ‘p_min_all’,
‘u_max_all’, ‘u_min_all’), and the final quantities (‘p_final’,
‘u_final’). The averaged quantities are indexed as
sensor_data.p_max(sensor_point_index) or
sensor_data(rect_index).p_max(x_index, y_index) if using rectangular
corners, while the final and ‘all’ quantities are returned over the
entire grid and are always indexed as sensor_data.p_final(nx, ny),
regardless of the type of sensor mask.</p>
<p>kspaceFirstOrder2D may also be used for time reversal image
reconstruction by assigning the time varying pressure recorded over
an arbitrary sensor surface to the input field
sensor.time_reversal_boundary_data. This data is then enforced in
time reversed order as a time varying Dirichlet boundary condition
over the sensor surface given by sensor.mask. The boundary data must
be indexed as sensor.time_reversal_boundary_data(sensor_point_index,
time_index). If sensor.mask is given as a set of Cartesian
coordinates, the boundary data must be given in the same order. An
equivalent binary sensor mask (computed using nearest neighbour
interpolation) is then used to place the pressure values into the
computational grid at each time step. If sensor.mask is given as a
binary matrix of sensor points, the boundary data must be ordered
using MATLAB’s standard column-wise linear matrix indexing. If no
additional inputs are required, the source input can be replaced with
an empty array [].</p>
<p>Acoustic attenuation compensation can also be included during time
reversal image reconstruction by assigning the absorption parameters
medium.alpha_coeff and medium.alpha_power and reversing the sign of
the absorption term by setting medium.alpha_sign = [-1, 1]. This
forces the propagating waves to grow according to the absorption
parameters instead of decay. The reconstruction should then be
regularised by assigning a filter to medium.alpha_filter (this can be
created using getAlphaFilter).</p>
<p>Note: To run a simple photoacoustic image reconstruction example
using time reversal (that commits the ‘inverse crime’ of using the
same numerical parameters and model for data simulation and image
reconstruction), the sensor_data returned from a k-Wave simulation
can be passed directly to sensor.time_reversal_boundary_data with the
input fields source.p0 and source.p removed or set to zero.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kgrid</strong> – kWaveGrid instance</p></li>
<li><p><strong>medium</strong> – kWaveMedium instance</p></li>
<li><p><strong>source</strong> – kWaveSource instance</p></li>
<li><p><strong>sensor</strong> – kWaveSensor instance</p></li>
<li><p><strong>**kwargs</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder2D.kspaceFirstOrder2DC">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder2D.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrder2DC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder2D.kspaceFirstOrder2DC" title="Permalink to this definition"></a></dt>
<dd><p>2D time-domain simulation of wave propagation using C++ code.</p>
<p>kspaceFirstOrder2DC provides a blind interface to the C++ version of
kspaceFirstOrder2D (called kspaceFirstOrder-OMP) in the same way as
kspaceFirstOrder3DC. Note, the C++ code does not support all input
options, and all display options are ignored (only command line
outputs are given). See the k-Wave user manual for more information.
The function works by appending the optional input ‘SaveToDisk’ to
the user inputs and then calling kspaceFirstOrder2D to save the input
files to disk. The contents of sensor.record (if set) are parsed as
input flags, and the C++ code is run using the system command. The
output files are then automatically loaded from disk and returned in
the same fashion as kspaceFirstOrder2D. The input and output files
are saved to the temporary directory native to the operating system,
and are deleted after the function runs.
For small simulations, running the simulation on a smaller number of
cores can improve performance as the matrices are often small enough
to fit within cache. It is recommended to adjust the value of
‘NumThreads’ to optimise performance for a given simulation size and
computer hardware. By default, simulations smaller than 128^2 are
set to run using a single thread (this behaviour can be over-ridden
using the ‘NumThreads’ option). In some circumstances, for very small
simulations, the C++ code can be slower than the MATLAB code.
This function requires the C++ binary/executable of
kspaceFirstOrder-OMP to be downloaded from
<a class="reference external" href="http://www.k-wave.org/download.php">http://www.k-wave.org/download.php</a> and placed in the “binaries”
directory of the k-Wave toolbox (the same binary is used for
simulations in 2D, 3D, and axisymmetric coordinates). Alternatively,
the name and location of the binary can be  specified using the
optional input parameters ‘BinaryName’ and ‘BinariesPath’.</p>
<p>This function is essentially a wrapper and directly uses the capabilities
of kspaceFirstOrder3DC by replacing the binary name with the name of the
GPU binary.
:param **kwargs:</p>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder2D.kspaceFirstOrder2DG">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder2D.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrder2DG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder2D.kspaceFirstOrder2DG" title="Permalink to this definition"></a></dt>
<dd><p>2D ime-domain simulation of wave propagation on a GPU using C++ CUDA code.</p>
<p>kspaceFirstOrder2DG provides a blind interface to the C++/CUDA
version of kspaceFirstOrder2D (called kspaceFirstOrder-CUDA) in the
same way as kspaceFirstOrder3DC. Note, the C++ code does not support
all input options, and all display options are ignored (only command
line outputs are given). See the k-Wave user manual for more
information.
The function works by appending the optional input ‘SaveToDisk’ to
the user inputs and then calling kspaceFirstOrder2D to save the input
files to disk. The contents of sensor.record (if set) are parsed as
input flags, and the C++ code is run using the system command. The
output files are then automatically loaded from disk and returned in
the same fashion as kspaceFirstOrder2D. The input and output files
are saved to the temporary directory native to the operating system,
and are deleted after the function runs.
This function requires the C++ binary/executable of
kspaceFirstOrder-CUDA to be downloaded from
<a class="reference external" href="http://www.k-wave.org/download.php">http://www.k-wave.org/download.php</a> and placed in the “binaries”
directory of the k-Wave toolbox (the 2D and 3D code use the same
binary). Alternatively, the name and location of the binary can be
specified using the optional input parameters ‘BinaryName’ and
‘BinariesPath’.</p>
<p>This function is essentially a wrapper and directly uses the capabilities
of kspaceFirstOrder3DC by replacing the binary name with the name of the
GPU binary.</p>
</dd></dl>

</div>
<div class="section" id="module-kwave.kspaceFirstOrder3D">
<span id="kspacefirstorder-3d"></span><h2>kSpaceFirstOrder 3D<a class="headerlink" href="#module-kwave.kspaceFirstOrder3D" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder3D.kspaceFirstOrder3D">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder3D.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrder3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kgrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">medium</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder3D.kspaceFirstOrder3D" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>3D time-domain simulation of wave propagation.</p>
<p>kspaceFirstOrder3D simulates the time-domain propagation of
compressional waves through a three-dimensional homogeneous or
heterogeneous acoustic medium given four input structures: kgrid,
medium, source, and sensor. The computation is based on a first-order
k-space model which accounts for power law absorption and a
heterogeneous sound speed and density. If medium.BonA is specified,
cumulative nonlinear effects are also modelled. At each time-step
(defined by kgrid.dt and kgrid.Nt or kgrid.t_array), the acoustic
field parameters at the positions defined by sensor.mask are recorded
and stored. If kgrid.t_array is set to ‘auto’, this array is
automatically generated using the makeTime method of the kWaveGrid
class. An anisotropic absorbing boundary layer called a perfectly
matched layer (PML) is implemented to prevent waves that leave one
side of the domain being reintroduced from the opposite side (a
consequence of using the FFT to compute the spatial derivatives in
the wave equation). This allows infinite domain simulations to be
computed using small computational grids.</p>
<p>For a homogeneous medium the formulation is exact and the time-steps
are only limited by the effectiveness of the perfectly matched layer.
For a heterogeneous medium, the solution represents a leap-frog
pseudospectral method with a k-space correction that improves the
accuracy of computing the temporal derivatives. This allows larger
time-steps to be taken for the same level of accuracy compared to
conventional pseudospectral time-domain methods. The computational
grids are staggered both spatially and temporally.</p>
<p>An initial pressure distribution can be specified by assigning a
matrix (the same size as the computational grid) of arbitrary numeric
values to source.p0. A time varying pressure source can similarly be
specified by assigning a binary matrix (i.e., a matrix of 1’s and 0’s
with the same dimensions as the computational grid) to source.p_mask
where the 1’s represent the grid points that form part of the source.
The time varying input signals are then assigned to source.p. This
can be a single time series (in which case it is applied to all
source elements), or a matrix of time series following the source
elements using MATLAB’s standard column-wise linear matrix index
ordering. A time varying velocity source can be specified in an
analogous fashion, where the source location is specified by
source.u_mask, and the time varying input velocity is assigned to
source.ux, source.uy, and source.uz.</p>
<p>The field values are returned as arrays of time series at the sensor
locations defined by sensor.mask. This can be defined in three
different ways. (1) As a binary matrix (i.e., a matrix of 1’s and 0’s
with the same dimensions as the computational grid) representing the
grid points within the computational grid that will collect the data.
(2) As the grid coordinates of two opposing corners of a cuboid in
the form [x1; y1; z1; x2; y2; z2]. This is equivalent to using a
binary sensor mask covering the same region, however, the output is
indexed differently as discussed below. (3) As a series of Cartesian
coordinates within the grid which specify the location of the
pressure values stored at each time step. If the Cartesian
coordinates don’t exactly match the coordinates of a grid point, the
output values are calculated via interpolation. The Cartesian points
must be given as a 3 by N matrix corresponding to the x, y, and z
positions, respectively, where the Cartesian origin is assumed to be
in the center of the grid. If no output is required, the sensor input
can be replaced with an empty array []. Both the source and sensor
inputs can also be replaced by an object of the kWaveTransducer
class.</p>
<p>If sensor.mask is given as a set of Cartesian coordinates, the
computed sensor_data is returned in the same order. If sensor.mask is
given as a binary matrix, sensor_data is returned using MATLAB’s
standard column-wise linear matrix index ordering. In both cases, the
recorded data is indexed as sensor_data(sensor_point_index,
time_index). For a binary sensor mask, the field values at a
particular time can be restored to the sensor positions within the
computation grid using unmaskSensorData. If sensor.mask is given as a
list of cuboid corners, the recorded data is indexed as
sensor_data(cuboid_index).p(x_index, y_index, z_index, time_index),
where x_index, y_index, and z_index correspond to the grid index
within the cuboid, and cuboid_index corresponds to the number of the
cuboid if more than one is specified.</p>
<p>By default, the recorded acoustic pressure field is passed directly
to the output sensor_data. However, other acoustic parameters can
also be recorded by setting sensor.record to a cell array of the form
{‘p’, ‘u’, ‘p_max’, …}. For example, both the particle velocity and
the acoustic pressure can be returned by setting sensor.record =
{‘p’, ‘u’}. If sensor.record is given, the output sensor_data is
returned as a structure with the different outputs appended as
structure fields. For example, if sensor.record = {‘p’, ‘p_final’,
‘p_max’, ‘u’}, the output would contain fields sensor_data.p,
sensor_data.p_final, sensor_data.p_max, sensor_data.ux,
sensor_data.uy, and sensor_data.uz. Most of the output parameters are
recorded at the given sensor positions and are indexed as
sensor_data.field(sensor_point_index, time_index) or
sensor_data(cuboid_index).field(x_index, y_index, z_index,
time_index) if using a sensor mask defined as cuboid corners. The
exceptions are the averaged quantities (‘p_max’, ‘p_rms’, ‘u_max’,
‘p_rms’, ‘I_avg’), the ‘all’ quantities (‘p_max_all’, ‘p_min_all’,
‘u_max_all’, ‘u_min_all’), and the final quantities (‘p_final’,
‘u_final’). The averaged quantities are indexed as
sensor_data.p_max(sensor_point_index) or
sensor_data(cuboid_index).p_max(x_index, y_index, z_index) if using
cuboid corners, while the final and ‘all’ quantities are returned
over the entire grid and are always indexed as
sensor_data.p_final(nx, ny, nz), regardless of the type of sensor
mask.</p>
<p>kspaceFirstOrder3D may also be used for time reversal image
reconstruction by assigning the time varying pressure recorded over
an arbitrary sensor surface to the input field
sensor.time_reversal_boundary_data. This data is then enforced in
time reversed order as a time varying Dirichlet boundary condition
over the sensor surface given by sensor.mask. The boundary data must
be indexed as sensor.time_reversal_boundary_data(sensor_point_index,
time_index). If sensor.mask is given as a set of Cartesian
coordinates, the boundary data must be given in the same order. An
equivalent binary sensor mask (computed using nearest neighbour
interpolation) is then used to place the pressure values into the
computational grid at each time step. If sensor.mask is given as a
binary matrix of sensor points, the boundary data must be ordered
using MATLAB’s standard column-wise linear matrix indexing. If no
additional inputs are required, the source input can be replaced with
an empty array [].</p>
<p>Acoustic attenuation compensation can also be included during time
reversal image reconstruction by assigning the absorption parameters
medium.alpha_coeff and medium.alpha_power and reversing the sign of
the absorption term by setting medium.alpha_sign = [-1, 1]. This
forces the propagating waves to grow according to the absorption
parameters instead of decay. The reconstruction should then be
regularised by assigning a filter to medium.alpha_filter (this can be
created using getAlphaFilter).</p>
<p>Note: To run a simple photoacoustic image reconstruction example
using time reversal (that commits the ‘inverse crime’ of using the
same numerical parameters and model for data simulation and image
reconstruction), the sensor_data returned from a k-Wave simulation
can be passed directly to sensor.time_reversal_boundary_data with the
input fields source.p0 and source.p removed or set to zero.</p>
<p>Note: For heterogeneous medium parameters, medium.sound_speed and
medium.density must be given in matrix form with the same dimensions as
kgrid. For homogeneous medium parameters, these can be given as single
numeric values. If the medium is homogeneous and velocity inputs or
outputs are not required, it is not necessary to specify medium.density.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kgrid</strong> – kWaveGrid instance</p></li>
<li><p><strong>medium</strong> – kWaveMedium instance</p></li>
<li><p><strong>source</strong> – kWaveSource instance</p></li>
<li><p><strong>sensor</strong> – kWaveSensor instance</p></li>
<li><p><strong>**kwargs</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder3D.kspaceFirstOrder3DC">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder3D.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrder3DC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder3D.kspaceFirstOrder3DC" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>3D time-domain simulation of wave propagation using C++ code.</p>
<p>kspaceFirstOrder3DC provides a blind interface to the C++ version of
kspaceFirstOrder3D (called kspaceFirstOrder-OMP). Note, the C++ code
does not support all input options, and all display options are
ignored (only command line outputs are given). See the k-Wave user
manual for more information.</p>
<p>The function works by appending the optional input ‘SaveToDisk’ to
the user inputs and then calling kspaceFirstOrder3D to save the input
files to disk. The contents of sensor.record (if set) are parsed as
input flags, and the C++ code is run using the system command. The
output files are then automatically loaded from disk and returned in
the same fashion as kspaceFirstOrder3D. The input and output files
are saved to the temporary directory native to the operating system,
and are deleted after the function runs.</p>
<p>This function is not recommended for large simulations, as the input
variables will reside twice in main memory (once in MATLAB, and once
in C++). For large simulations, the C++ code should be called outside
of MATLAB. See the k-Wave manual for more information.</p>
<p>This function requires the C++ binary/executable of
kspaceFirstOrder-OMP to be downloaded from
<a class="reference external" href="http://www.k-wave.org/download.php">http://www.k-wave.org/download.php</a> and placed in the “binaries”
directory of the k-Wave toolbox (the same binary is used for
simulations in 2D, 3D, and axisymmetric coordinates). Alternatively,
the name and  location of the binary can be specified using the
optional input parameters ‘BinaryName’ and ‘BinariesPath’.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – </p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrder3D.kspaceFirstOrder3DG">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrder3D.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrder3DG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrder3D.kspaceFirstOrder3DG" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>3D time-domain simulation of wave propagation on a GPU using C++ CUDA code.</p>
<p>kspaceFirstOrder3DG provides a blind interface to the C++/CUDA
version of kspaceFirstOrder3D (called kspaceFirstOrder-CUDA) in the
same way as kspaceFirstOrder3DC. Note, the C++ code does not support
all input options, and all display options are ignored (only command
line outputs are given). See the k-Wave user manual for more
information.</p>
<p>The function works by appending the optional input ‘SaveToDisk’ to
the user inputs and then calling kspaceFirstOrder3D to save the input
files to disk. The contents of sensor.record (if set) are parsed as
input flags, and the C++ code is run using the system command. The
output files are then automatically loaded from disk and returned in
the same fashion as kspaceFirstOrder3D. The input and output files
are saved to the temporary directory native to the operating system,
and are deleted after the function runs.</p>
<p>This function requires the C++ binary/executable of
kspaceFirstOrder-CUDA to be downloaded from
<a class="reference external" href="http://www.k-wave.org/download.php">http://www.k-wave.org/download.php</a> and placed in the “binaries”
directory of the k-Wave toolbox. Alternatively, the name and location
of the binary can be specified using the optional input parameters
‘BinaryName’ and ‘BinariesPath’.</p>
<p>This function is essentially a wrapper and directly uses the capabilities
of kspaceFirstOrder3DC by replacing the binary name with the name of the
GPU binary.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – </p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

</div>
<div class="section" id="module-kwave.kspaceFirstOrderAS">
<span id="kspacefirstorder-axisymmetric"></span><h2>kSpaceFirstOrder Axisymmetric<a class="headerlink" href="#module-kwave.kspaceFirstOrderAS" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrderAS.kspaceFirstOrderAS">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrderAS.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrderAS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kgrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">medium</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrderAS.kspaceFirstOrderAS" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Axisymmetric time-domain simulation of wave propagation.</p>
<p>kspaceFirstOrderAS simulates the time-domain propagation of
compressional waves through an axisymmetric homogeneous or
heterogeneous acoustic medium. The code is functionally very similar
to kspaceFirstOrder2D. However, a 2D axisymmetric coordinate system
is used instead of a 2D Cartesian coordinate system. In this case, x
corresponds to the axial dimension, and y corresponds to the radial
dimension. In the radial dimension, the first grid point corresponds
to the grid origin, i.e., y = 0. In comparison, for
kspaceFirstOrder2D, the Cartesian point y = 0 is in the middle of the
computational grid.</p>
<p>The input structures kgrid, medium, source, and sensor are defined in
exactly the same way as for kspaceFirstOrder2D. However,
computationally, there are several key differences. First, the
axisymmetric code solves the coupled first-order equations accounting
for viscous absorption (not power law), so only medium.alpha_power =
2 is supported. This value is set by default, and doesn’t need to be
defined. This also means that medium.alpha_mode and
medium.alpha_filter are not supported. Second, for a homogeneous
medium, the k-space correction used to counteract the numerical
dispersion introduced by the finite-difference time step is not exact
(as it is for the other fluid codes). However, the approximate
k-space correction still works very effectively, so dispersion errors
should still be small. See kspaceFirstOrder2D for additional details
on the function inputs.</p>
<p>In the x-dimension (axial), the FFT is used to compute spatial
gradients. In the y-dimension (radial), two choices of symmetry are
possible. These are whole-sample-symmetric on the interior radial
boundary (y = 0) and either whole-sample-symmetric or
whole-sample-asymmetric on the exterior radial boundary. These are
abbreviated WSWA and WSWS. The WSWA and WSWS symmetries are
implemented using both discrete trigonometric transforms (DTTs), and
via the FFT by manually mirroring the domain. The latter options are
abbreviated as WSWA-FFT and WSWS-FFT. The WSWA/WSWS options and the
corresponding WSWA-FFT/WSWS-FFT options agree to machine precision.
When using the PML, the choice of symmetry doesn’t matter, and all
options give very similar results (to several decimal places).
Computationally, the DTT implementations are more efficient, but
require additional compiled MATLAB functions (not currently part of
k-Wave). The symmetry can be set by using the optional input
‘RadialSymmetry’. The WSWA-FFT symmetry is set by default.</p>
<p>Note: For heterogeneous medium parameters, medium.sound_speed and
medium.density must be given in matrix form with the same dimensions as
kgrid. For homogeneous medium parameters, these can be given as single
numeric values. If the medium is homogeneous and velocity inputs or
outputs are not required, it is not necessary to specify medium.density.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kgrid</strong> – kWaveGrid instance</p></li>
<li><p><strong>medium</strong> – kWaveMedium instance</p></li>
<li><p><strong>source</strong> – kWaveSource instance</p></li>
<li><p><strong>sensor</strong> – kWaveSensor instance</p></li>
<li><p><strong>**kwargs</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kwave.kspaceFirstOrderAS.kspaceFirstOrderASC">
<span class="sig-prename descclassname"><span class="pre">kwave.kspaceFirstOrderAS.</span></span><span class="sig-name descname"><span class="pre">kspaceFirstOrderASC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kwave.kspaceFirstOrderAS.kspaceFirstOrderASC" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Axisymmetric time-domain simulation of wave propagation using C++ code.</p>
<p>kspaceFirstOrderASC provides a blind interface to the C++ version of
kspaceFirstOrderAS (called kspaceFirstOrder-OMP) in the same way as
kspaceFirstOrder3DC. Note, the C++ code does not support all input
options, and all display options are ignored (only command line
outputs are given). See the k-Wave user manual for more information.</p>
<p>The function works by appending the optional input ‘SaveToDisk’ to
the user inputs and then calling kspaceFirstOrderAS to save the input
files to disk. The contents of sensor.record (if set) are parsed as
input flags, and the C++ code is run using the system command. The
output files are then automatically loaded from disk and returned in
the same fashion as kspaceFirstOrderAS. The input and output files
are saved to the temporary directory native to the operating system,
and are deleted after the function runs.</p>
<p>For small simulations, running the simulation on a smaller number of
cores can improve performance as the matrices are often small enough
to fit within cache. It is recommended to adjust the value of
‘NumThreads’ to optimise performance for a given simulation size and
computer hardware. By default, simulations smaller than 128^2 are
set to run using a single thread (this behaviour can be over-ridden
using the ‘NumThreads’ option). In some circumstances, for very small
simulations, the C++ code can be slower than the MATLAB code.</p>
<p>This function requires the C++ binary/executable of
kspaceFirstOrder-OMP to be downloaded from
<a class="reference external" href="http://www.k-wave.org/download.php">http://www.k-wave.org/download.php</a> and placed in the “binaries”
directory of the k-Wave toolbox (the same binary is used for
simulations in 2D, 3D, and axisymmetric coordinates). Alternatively,
the name and location  of the binary can be specified using the
optional input parameters ‘BinaryName’ and ‘BinariesPath’.</p>
<p>This function is essentially a wrapper and directly uses the capabilities
of kspaceFirstOrder3DC by replacing the binary name with the name of the
GPU binary.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – </p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ksource.html" class="btn btn-neutral float-left" title="kSource" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ksimulation.html" class="btn btn-neutral float-right" title="kWaveSimulation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Walter Simson, Farid Yagubbayli.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>